<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content=mNote Mac 2.5.11"/><meta name="created" content="2017-07-05T10:00:30Z"/><meta name="updated" content="2017-07-05T10:00:34Z"/><title>我们知道，计算机CPU和内存的交互是最频繁的，内存是我们的高速缓存区，用户磁盘和CPU的交互，而CPU运转速度越来越快，磁盘远远跟不上CPU的读写速度，才设计了内存，用户缓冲用户IO等待导致CPU的</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div class="multicntwrap" style="margin:0px;padding:0px;font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;font-variant-ligatures:normal;orphans:2;widows:2;background-color:#fefef2;"><div class="multicnt" style="margin:0px;padding:0px;"><div style="margin:0px;padding:0px;"><h3 class="title pre fs1" style="margin:10px 0px;padding:0px;font-size:16px;line-height:1.5;">我们知道，计算机<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">CPU</span>和内存的交互是最频繁的，内存是我们的高速缓存区，用户磁盘和<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">CPU</span>的交互，而<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">CPU</span>运转速度越来越快，磁盘远远跟不上<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">CPU</span>的读写速度，才设计了内存，用户缓冲用户<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">IO</span>等待导致<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">CPU</span>的等待成本，但是随着<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">CPU</span>的发展，内存的读写速度也远远跟不上<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">CPU</span>的读写速度，因此，为了解决这一纠纷，<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">CPU</span>厂商在每颗<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">CPU</span>上加入了高速缓存，用来缓解这种症状，因此，现在<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">CPU</span>同内存交互就变成了下面的样子。</h3>
</div>
</div>
</div>
<div class="bct fc05 fc11 nbw-blog ztag" style="margin:0px;padding:0px;font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;font-variant-ligatures:normal;orphans:2;widows:2;background-color:#fefef2;"><div style="margin:0px;padding:0px;"><img src="http://images.cnitblog.com/i/485345/201405/300841418849725.jpg" alt="" style="margin:0px;padding:0px;border:0px;max-width:900px;" />&nbsp;</div>
<p style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;同样，根据摩尔定律，我们知道单核</p>
<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">CPU</span>的主频不可能无限制的增长，要想很多的提升新能，需要多个处理器协同工作，&nbsp;<a href="http://detail.zol.com.cn/cpu_index/subcate28_125_list_1.html" rel="nofollow" style="margin:0px;padding:0px;color:#075db3;">Intel</a>总裁的贝瑞特单膝下跪事件标志着多核时代的到来。<p style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<div style="margin:0px;padding:0px;">&nbsp;<img src="http://images.cnitblog.com/i/485345/201405/300842074161092.jpg" alt="" style="margin:0px;padding:0px;border:0px;max-width:900px;" /></div>
<p style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;基于高速缓存的存储交互很好的解决了处理器与内存之间的矛盾，也引入了新的问题：缓存一致性问题。在多处理器系统中，每个处理器有自己的高速缓存，而他们又共享同一块内存（下文成主存，</p>
<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">main memory&nbsp;</span>主要内存），当多个处理器运算都涉及到同一块内存区域的时候，就有可能发生缓存不一致的现象。为了解决这一问题，需要各个处理器运行时都遵循一些协议，在运行时需要将这些协议保证数据的一致性。这类协议包括<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">MSI</span>、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">MESI</span>、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">MOSI</span>、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Synapse</span>、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Firely</span>、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">DragonProtocol</span>等。如下图所示<p style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;<img src="http://images.cnitblog.com/i/485345/201405/300842245881879.jpg" alt="" style="margin:0px;padding:0px;border:0px;max-width:900px;" /></p>
<div style="margin:0px;padding:0px;">&nbsp;</div>
<p style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;Java</p>
虚拟机内存模型中定义的访问操作与物理计算机处理的基本一致！<p style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;<img src="http://images.cnitblog.com/i/485345/201405/300853426033674.jpg" alt="" style="margin:0px;padding:0px;border:0px;max-width:900px;" /></p>
<div style="margin:0px;padding:0px;">&nbsp;</div>
<p style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;Java</p>
中通过多线程机制使得多个任务同时执行处理，所有的线程共享<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">JVM</span>内存区域<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">main memory</span>，而每个线程又单独的有自己的工作内存，当线程与内存区域进行交互时，数据从主存拷贝到工作内存，进而交由线程处理（操作码<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">+</span>操作数）。更多信息我们会在后面的《深入<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">JVM—JVM</span>类执行机制中详细解说》。<p style="margin:10px auto;padding:0px;line-height:1.5;">在之前，我们也已经提到，<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">JVM</span>的逻辑内存模型如下：</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<div style="margin:0px;padding:0px;">&nbsp;<img src="http://images.cnitblog.com/i/485345/201405/300854081661499.jpg" alt="" style="margin:0px;padding:0px;border:0px;max-width:900px;" /></div>
<p style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;我们现在来逐个的看下每个到底是做什么的！</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">1、程序计数器</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">程序计数器（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Program Counter Register</span>）是一块较小的内存空间，它的作用可以看</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">由于<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">存区域为<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">“</span>线程私有<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">”</span>的内存。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">如果线程正在执行的是一个<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>方法，这个计数器记录的是正在执行的虚拟机字节</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">码指令的地址；如果正在执行的是<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Natvie&nbsp;</span>方法，这个计数器值则为空（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Undefined</span>）。此</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">内存区域是唯一一个在<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚拟机规范中没有规定任何<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">OutOfMemoryError&nbsp;</span>情况的区域。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">2、Java&nbsp;</span>虚拟机栈</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">与程序计数器一样，<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚拟机栈（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java Virtual Machine Stacks</span>）也是线程私有的，</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">它的生命周期与线程相同。虚拟机栈描述的是<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>方法执行的内存模型：每个方法被执</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">行的时候都会同时创建一个栈帧（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Stack Frame&nbsp;</span>①）用于存储局部变量表、操作栈、动态</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">虚拟机栈中从入栈到出栈的过程。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">经常有人把<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>内存区分为堆内存（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Heap</span>）和栈内存（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Stack</span>），这种分法比较粗</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">糙，<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">“</span>堆<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">”</span>在后</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">面会专门讲述，而所指的<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">“</span>栈<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">”</span>就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">量表部分。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">局部变量表存放了编译期可知的各种基本数据类型（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">boolean</span>、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">byte</span>、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">char</span>、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">short</span>、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">int</span>、</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">float</span>、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">long</span>、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">double</span>）、对象引用（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">reference&nbsp;</span>类型，它不等同于对象本身，根据不同的虚拟</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">者其他与此对象相关的位置）和<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">returnAddress&nbsp;</span>类型（指向了一条字节码指令的地址）。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">其中<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">64&nbsp;</span>位长度的<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">long&nbsp;</span>和<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">double&nbsp;</span>类型的数据会占用<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">2&nbsp;</span>个局部变量空间（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Slot</span>），其余</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">的数据类型只占用<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">1&nbsp;</span>个。局部变量表所需的内存空间在编译期间完成分配，当进入一个</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">不会改变局部变量表的大小。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">在<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">于虚拟机所允许的深度，将抛出<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">StackOverflowError&nbsp;</span>异常；如果虚拟机栈可以动态扩展</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">（当前大部分的<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚拟机都可动态扩展，只不过<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚拟机规范中也允许固定长度的</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">虚拟机栈），当扩展时无法申请到足够的内存时会抛出<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">OutOfMemoryError&nbsp;</span>异常。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">3</span>、本地方法栈</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">本地方法栈（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Native Method Stacks</span>）与虚拟机栈所发挥的作用是非常相似的，其</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">区别不过是虚拟机栈为虚拟机执行<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>方法（也就是字节码）服务，而本地方法栈则</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">是为虚拟机使用到的<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Native&nbsp;</span>方法服务。虚拟机规范中对本地方法栈中的方法使用的语</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">有的虚拟机（譬如<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Sun HotSpot&nbsp;</span>虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">与虚拟机栈一样，本地方法栈区域也会抛出<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">StackOverflowError&nbsp;</span>和<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">OutOfMemoryError</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">异常。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">4、Java&nbsp;</span>堆</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">对于大多数应用来说，<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java Heap</span>）是<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚拟机所管理的内存中最大的</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">一块。<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">JIT&nbsp;</span>编译器</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">的变化发生，所有的对象都分配在堆上也渐渐变得不是那么<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">“</span>绝对<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">”</span>了。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆是垃圾收集器管理的主要区域，因此很多时候也被称做<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">“GC&nbsp;</span>堆<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">”</span>（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Garbage</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Collected Heap</span>，幸好国内没翻译成<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">“</span>垃圾堆<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">”</span>）。如果从内存回收的角度看，由于现在</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">收集器基本都是采用的分代收集算法，所以<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆中还可以细分为：新生代和老年代；</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">再细致一点的有<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Eden&nbsp;</span>空间、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">From Survivor&nbsp;</span>空间、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">To Survivor&nbsp;</span>空间等。如果从内存分配</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">的角度看，线程共享的<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆中可能划分出多个线程私有的分配缓冲区（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Thread Local</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Allocation Buffer</span>，<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">TLAB</span>）。不过，无论如何划分，都与存放内容无关，无论哪个区域，</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">内存。在本章中，我们仅仅针对内存区域的作用进行讨论，<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆中的上述各个区域的</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">分配和回收等细节将会是下一章的主题。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">根据<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚拟机规范的规定，<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆可以处于物理上不连续的内存空间中，只要</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">-Xmx</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">和<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">-Xms&nbsp;</span>控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">OutOfMemoryError&nbsp;</span>异常。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">4</span>、方法区</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">方法区（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Method Area</span>）与<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆一样，是各个线程共享的内存区域，它用于存</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">然<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Non-</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Heap</span>（非堆），目的应该是与<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆区分开来。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">对于习惯在<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">HotSpot&nbsp;</span>虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">称为<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">“</span>永久代<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">”</span>（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Permanent Generation</span>），本质上两者并不等价，仅仅是因为<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">HotSpot&nbsp;</span>虚</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">拟机的设计团队选择把<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">GC&nbsp;</span>分代收集扩展至方法区，或者说使用永久代来实现方法区而</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">已。对于其他虚拟机（如<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">BEA JRockit</span>、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">IBM J9&nbsp;</span>等）来说是不存在永久代的概念的。即</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">使是<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">HotSpot&nbsp;</span>虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">“</span>搬家<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">”</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">至<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Native Memory&nbsp;</span>来实现方法区的规划了。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚拟机规范对这个区域的限制非常宽松，除了和<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆一样不需要连续的内</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">样<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">“</span>永久<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">”</span>存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">载，一般来说这个区域的回收<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">“</span>成绩<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">”</span>比较难以令人满意，尤其是类型的卸载，条件</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">相当苛刻，但是这部分区域的回收确实是有必要的。在<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Sun&nbsp;</span>公司的<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">BUG&nbsp;</span>列表中，曾出</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">现过的若干个严重的<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">BUG&nbsp;</span>就是由于低版本的<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">HotSpot&nbsp;</span>虚拟机对此区域未完全回收而导</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">致内存泄漏。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">根据<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">OutOfMemoryError&nbsp;</span>异常。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">5</span>、运行时常量池</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">运行时常量池（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Runtime Constant Pool</span>）是方法区的一部分。<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Class&nbsp;</span>文件中除了有</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Constant Pool</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Table</span>），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">到方法区的运行时常量池中。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚拟机对<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Class&nbsp;</span>文件的每一部分（自然也包括常量池）的格式都有严格的规</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">装载和执行。但对于运行时常量池，<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚拟机规范没有做任何细节的要求，不同的</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">了保存<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Class&nbsp;</span>文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">量池中①。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">运行时常量池相对于<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Class&nbsp;</span>文件常量池的另外一个重要特征是具备动态性，<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>语</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">言并不要求常量一定只能在编译期产生，也就是并非预置入<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Class&nbsp;</span>文件中常量池的内容</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">人员利用得比较多的便是<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">String&nbsp;</span>类的<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">intern()&nbsp;</span>方法。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">法再申请到内存时会抛出<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">OutOfMemoryError&nbsp;</span>异常</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">6</span>、直接内存</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">直接内存（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Direct Memory</span>）并不是虚拟机运行时数据区的一部分，也不是<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">OutOfMemoryError&nbsp;</span>异常出现，所以我们放到这里一起讲解。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">在<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">JDK 1.4&nbsp;</span>中新加入了<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">NIO</span>（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">New Input/Output</span>）类，引入了一种基于通道（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Channel</span>）</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">与缓冲区（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Buffer</span>）的<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">I/O&nbsp;</span>方式，它可以使用<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Native&nbsp;</span>函数库直接分配堆外内存，然</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">后通过一个存储在<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆里面的<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">DirectByteBuffer&nbsp;</span>对象作为这块内存的引用进行</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">操作。这样能在一些场景中显著提高性能，因为避免了在<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆和<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Native&nbsp;</span>堆中来</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">回复制数据。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">显然，本机直接内存的分配不会受到<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆大小的限制，但是，既然是内存，则</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">肯定还是会受到本机总内存（包括<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">RAM&nbsp;</span>及<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">SWAP&nbsp;</span>区或者分页文件）的大小及处理器</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">-Xmx</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">（包括物理上的和操作系统级的限制），从而导致动态扩展时出现<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">OutOfMemoryError</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">异常。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">逻辑内存模型我们已经看到了，那当我们建立一个对象的时候是怎么进行访问的呢？</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">在<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>语言中，对象访问是如何进行的？对象访问在<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>栈、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆、方法区这三个最重要内存区</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">域之间的关联关系，如下面的这句代码：</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Object obj = new Object();</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">假设这句代码出现在方法体中，那<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">“Object obj”</span>这部分的语义将会反映到<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>栈</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">的本地变量表中，作为一个<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">reference&nbsp;</span>类型数据出现。而<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">“new Object()”</span>这部分的语义</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">将会反映到<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆中，形成一块存储了<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Object&nbsp;</span>类型所有实例数据值（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Instance Data</span>，对</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">局（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Object Memory Layout</span>）的不同，这块内存的长度是不固定的。另外，在<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆中</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">址信息，这些类型数据则存储在方法区中。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">由于<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">reference&nbsp;</span>类型在<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>虚拟机规范里面只规定了一个指向对象的引用，并没有</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">定义这个引用应该通过哪种方式去定位，以及访问到<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆中的对象的具体位置，因此</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">指针。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">如果使用句柄访问方式，<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆中将会划分出一块内存来作为句柄池，<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">reference</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">具体地址信息，如下图所示。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;<img src="http://images.cnitblog.com/i/485345/201405/300854449949413.jpg" alt="" style="margin:0px;padding:0px;border:0px;max-width:900px;" /></p>
<div style="margin:0px;padding:0px;">&nbsp;</div>
<p style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;如果使用直接指针访问方式，</p>
<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆对象的布局中就必须考虑如何放置访问类型<p style="margin:10px auto;padding:0px;line-height:1.5;">数据的相关信息，<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">reference&nbsp;</span>中直接存储的就是对象地址，如下图所示</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<div style="margin:0px;padding:0px;">&nbsp;<img src="http://images.cnitblog.com/i/485345/201405/300855143845835.jpg" alt="" style="margin:0px;padding:0px;border:0px;max-width:900px;" /></div>
<p style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是</p>
<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">reference&nbsp;</span>中存<p style="margin:10px auto;padding:0px;line-height:1.5;">储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">会改变句柄中的实例数据指针，而<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">reference&nbsp;</span>本身不需要被修改。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">销，由于对象的访问在<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>中非常频繁，因此这类开销积少成多后也是一项非常可观的</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">执行成本。就本书讨论的主要虚拟机<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Sun HotSpot&nbsp;</span>而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">下面我们来看几个示例</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">1</span>、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆溢出</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">下面的程中我们限制<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆的大小为<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">20MB</span>，不可扩展（将堆的最小值<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">-Xms&nbsp;</span>参</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">数与最大值<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">-Xmx&nbsp;</span>参数设置为一样即可避免堆自动扩展），通过参数<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">-XX:+HeapDump</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">OnOutOfMemoryError&nbsp;</span>可以让虚拟机在出现内存溢出异常时<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Dump&nbsp;</span>出当前的内存堆转储</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">快照以便事后进行分析。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">参数设置如下</p>
<div style="margin:0px;padding:0px;">&nbsp;<img src="http://images.cnitblog.com/i/485345/201405/300855436667056.jpg" alt="" style="margin:0px;padding:0px;border:0px;max-width:900px;" /></div>
<div style="margin:0px;padding:0px;"><img src="http://images.cnitblog.com/i/485345/201405/300856054164811.jpg" alt="" style="margin:0px;padding:0px;border:0px;max-width:900px;" /></div>
<div style="margin:0px;padding:0px;"><img src="http://images.cnitblog.com/i/485345/201405/300856346812803.jpg" alt="" style="margin:0px;padding:0px;border:0px;max-width:900px;" /></div>
<div style="margin:0px;padding:0px;">&nbsp;</div>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">package</strong>&nbsp;com.yhj.jvm.memory.heap;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">import</strong>&nbsp;java.util.ArrayList;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">import</strong>&nbsp;java.util.List;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">/**</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@Described</strong>：堆溢出测试</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@VM</strong>&nbsp;<span style="margin:0px;padding:0px;line-height:1.5;text-decoration:underline;">args</span>:-verbose:gc -Xms20M -Xmx20M -XX:+PrintGCDetails</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@author</strong>&nbsp;YHJ create at 2011-11-12 下午07:52:22</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@FileNmae</strong>&nbsp;com.yhj.jvm.memory.heap.HeapOutOfMemory.java</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*/</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">public</strong>&nbsp;<strong style="margin:0px;padding:0px;">class</strong>&nbsp;HeapOutOfMemory {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; /**</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@param</strong>&nbsp;args</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@Author</strong>&nbsp;YHJ create at 2011-11-12 下午07:52:18</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*/</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">public</strong>&nbsp;<strong style="margin:0px;padding:0px;">static</strong>&nbsp;<strong style="margin:0px;padding:0px;">void</strong>&nbsp;main(String[] args) {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;TestCase&gt; cases =&nbsp;<strong style="margin:0px;padding:0px;">new</strong>&nbsp;ArrayList&lt;TestCase&gt;();</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">while</strong>(<strong style="margin:0px;padding:0px;">true</strong>){</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cases.add(<strong style="margin:0px;padding:0px;">new</strong>&nbsp;TestCase());</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; }</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">}</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">/**</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@Described</strong>：测试用例</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@author</strong>&nbsp;YHJ create at 2011-11-12 下午07:55:50</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@FileNmae</strong>&nbsp;com.yhj.jvm.memory.heap.HeapOutOfMemory.java</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*/</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">class</strong>&nbsp;TestCase{</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;</p>
<div style="margin:0px;padding:0px;"><p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">}</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><img src="http://images.cnitblog.com/i/485345/201405/300857293221377.jpg" alt="" style="margin:0px;padding:0px;border:0px;max-width:900px;" /></p>
</div>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆内存的<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">OutOfMemoryError</span>异常是实际应用中最常见的内存溢出异常情况。出现<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆内</div>
<div class="bct fc05 fc11 nbw-blog ztag" style="margin:0px;padding:0px;font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;font-variant-ligatures:normal;orphans:2;widows:2;background-color:#fefef2;"><p style="margin:10px auto;padding:0px;line-height:1.5;">存溢出时，异常堆栈信息<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">“java.lang.OutOfMemoryError”</span>会跟着进一步提示<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">“Java heap</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">space”</span>。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">要解决这个区域的异常，一般的手段是首先通过内存映像分析工具（如<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Eclipse</span></p>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Memory Analyzer</span>）对<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">dump&nbsp;</span>出来的堆转储快照进行分析，重点是确认内存中的对象是</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">否是必要的，也就是要先分清楚到底是出现了内存泄漏（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Memory Leak</span>）还是内存溢</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">出（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Memory Overflow</span>）。图<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">2-5&nbsp;</span>显示了使用<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Eclipse Memory Analyzer&nbsp;</span>打开的堆转储快</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">照文件。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">如果是内存泄漏，可进一步通过工具查看泄漏对象到<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">GC Roots&nbsp;</span>的引用链。于是就</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">能找到泄漏对象是通过怎样的路径与<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">GC Roots&nbsp;</span>相关联并导致垃圾收集器无法自动回收</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">它们的。掌握了泄漏对象的类型信息，以及<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">GC Roots&nbsp;</span>引用链的信息，就可以比较准确</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">地定位出泄漏代码的位置。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">如果不存在泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">虚拟机的堆参数（<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">-Xmx&nbsp;</span>与<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">-Xms</span>），与机器物理内存对比看是否还可以调大，从代码上</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">的内存消耗。</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">以上是处理<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">Java&nbsp;</span>堆内存问题的简略思路，处理这些问题所需要的知识、工具与经验</p>
<p style="margin:10px auto;padding:0px;line-height:1.5;">在后面的几次分享中我会做一些额外的分析。</p>
<div style="margin:0px;padding:0px;"><p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">2</span>、<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">java</span>栈溢出</p>
</div>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">package</strong>&nbsp;com.yhj.jvm.memory.stack;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">/**</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@Described</strong>：栈层级不足探究</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@VM</strong>&nbsp;<span style="margin:0px;padding:0px;line-height:1.5;text-decoration:underline;">args</span>:-Xss128k</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@author</strong>&nbsp;YHJ create at 2011-11-12 下午08:19:28</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@FileNmae</strong>&nbsp;com.yhj.jvm.memory.stack.StackOverFlow.java</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*/</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">public</strong>&nbsp;<strong style="margin:0px;padding:0px;">class</strong>&nbsp;StackOverFlow {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">private</strong>&nbsp;<strong style="margin:0px;padding:0px;">int</strong>&nbsp;i ;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">public</strong>&nbsp;<strong style="margin:0px;padding:0px;">void</strong>&nbsp;plus() {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; plus();</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; }</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; /**</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@param</strong>&nbsp;args</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@Author</strong>&nbsp;YHJ create at 2011-11-12 下午08:19:21</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*/</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">public</strong>&nbsp;<strong style="margin:0px;padding:0px;">static</strong>&nbsp;<strong style="margin:0px;padding:0px;">void</strong>&nbsp;main(String[] args) {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StackOverFlow stackOverFlow =&nbsp;<strong style="margin:0px;padding:0px;">new</strong>&nbsp;StackOverFlow();</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">try</strong>&nbsp;{</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stackOverFlow.plus();</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<strong style="margin:0px;padding:0px;">catch</strong>&nbsp;(Exception e) {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.<em style="margin:0px;padding:0px;">out</em>.println("Exception:stack length:"+stackOverFlow.i);</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<strong style="margin:0px;padding:0px;">catch</strong>&nbsp;(Error e) {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.<em style="margin:0px;padding:0px;">out</em>.println("Error:stack length:"+stackOverFlow.i);</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; }</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">}</p>
<div style="margin:0px;padding:0px;"><p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">3</span>、常量池溢出（常量池都有哪些信息，我们在后续的<span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">JVM</span>类文件结构中详细描述）</p>
</div>
<p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">&nbsp;</span></p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">package</strong>&nbsp;com.yhj.jvm.memory.constant;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">import</strong>&nbsp;java.util.ArrayList;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">import</strong>&nbsp;java.util.List;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">/**</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@Described</strong>：常量池内存溢出探究</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@VM</strong>&nbsp;<span style="margin:0px;padding:0px;line-height:1.5;text-decoration:underline;">args</span>&nbsp;: -XX:PermSize=10M -XX:MaxPermSize=10M</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@author</strong>&nbsp;YHJ create at 2011-10-30 下午04:28:30</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@FileNmae</strong>&nbsp;com.yhj.jvm.memory.constant.ConstantOutOfMemory.java</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*/</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">public</strong>&nbsp;<strong style="margin:0px;padding:0px;">class</strong>&nbsp;ConstantOutOfMemory {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; /**</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@param</strong>&nbsp;args</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@throws</strong>&nbsp;Exception</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@Author</strong>&nbsp;YHJ create at 2011-10-30 下午04:28:25</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*/</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">public</strong>&nbsp;<strong style="margin:0px;padding:0px;">static</strong>&nbsp;<strong style="margin:0px;padding:0px;">void</strong>&nbsp;main(String[] args)&nbsp;<strong style="margin:0px;padding:0px;">throws</strong>&nbsp;Exception {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">try</strong>&nbsp;{</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;String&gt; strings =&nbsp;<strong style="margin:0px;padding:0px;">new</strong>&nbsp;ArrayList&lt;String&gt;();</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">int</strong>&nbsp;i = 0;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">while</strong>(<strong style="margin:0px;padding:0px;">true</strong>){</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strings.add(String.<em style="margin:0px;padding:0px;">valueOf</em>(i++).intern());</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<strong style="margin:0px;padding:0px;">catch</strong>&nbsp;(Exception e) {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">throw</strong>&nbsp;e;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; }</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">}</p>
<div style="margin:0px;padding:0px;"><p style="margin:10px auto;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:Calibri;">4</span>、方法去溢出</p>
</div>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">package</strong>&nbsp;com.yhj.jvm.memory.methodArea;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">import</strong>&nbsp;java.lang.reflect.Method;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">import</strong>&nbsp;net.sf.cglib.proxy.Enhancer;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">import</strong>&nbsp;net.sf.cglib.proxy.MethodInterceptor;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">import</strong>&nbsp;net.sf.cglib.proxy.MethodProxy;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">/**</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@Described</strong>：方法区溢出测试</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;* 使用技术 CBlib</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@VM</strong>&nbsp;<span style="margin:0px;padding:0px;line-height:1.5;text-decoration:underline;">args</span>&nbsp;: -XX:PermSize=10M -XX:MaxPermSize=10M</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@author</strong>&nbsp;YHJ create at 2011-11-12 下午08:47:55</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@FileNmae</strong>&nbsp;com.yhj.jvm.memory.methodArea.MethodAreaOutOfMemory.java</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*/</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">public</strong>&nbsp;<strong style="margin:0px;padding:0px;">class</strong>&nbsp;MethodAreaOutOfMemory {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; /**</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@param</strong>&nbsp;args</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@Author</strong>&nbsp;YHJ create at 2011-11-12 下午08:47:51</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*/</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">public</strong>&nbsp;<strong style="margin:0px;padding:0px;">static</strong>&nbsp;<strong style="margin:0px;padding:0px;">void</strong>&nbsp;main(String[] args) {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">while</strong>(<strong style="margin:0px;padding:0px;">true</strong>){</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Enhancer enhancer =&nbsp;<strong style="margin:0px;padding:0px;">new</strong>&nbsp;Enhancer();</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enhancer.setSuperclass(TestCase.<strong style="margin:0px;padding:0px;">class</strong>);</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enhancer.setUseCache(<strong style="margin:0px;padding:0px;">false</strong>);</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enhancer.setCallback(<strong style="margin:0px;padding:0px;">new</strong>&nbsp;MethodInterceptor() {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @Override</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">public</strong>&nbsp;Object intercept(Object arg0, Method arg1, Object[] arg2,</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MethodProxy arg3)&nbsp;<strong style="margin:0px;padding:0px;">throws</strong>&nbsp;Throwable {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">return</strong>&nbsp;arg3.invokeSuper(arg0, arg2);</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enhancer.create();</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; }</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">}</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">/**</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@Described</strong>：测试用例</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@author</strong>&nbsp;YHJ create at 2011-11-12 下午08:53:09</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@FileNmae</strong>&nbsp;com.yhj.jvm.memory.methodArea.MethodAreaOutOfMemory.java</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*/</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">class</strong>&nbsp;TestCase{</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;</p>
<div style="margin:0px;padding:0px;"><p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">}</p>
</div>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">5、直接内存溢出</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">package</strong>&nbsp;com.yhj.jvm.memory.directoryMemory;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">import</strong>&nbsp;java.lang.reflect.Field;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">import</strong>&nbsp;sun.misc.Unsafe;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">/**</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@Described</strong>：直接内存溢出测试</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@VM</strong>&nbsp;<span style="margin:0px;padding:0px;line-height:1.5;text-decoration:underline;">args</span>: -Xmx20M -XX:MaxDirectMemorySize=10M</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@author</strong>&nbsp;YHJ create at 2011-11-12 下午09:06:10</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@FileNmae</strong>&nbsp;com.yhj.jvm.memory.directoryMemory.DirectoryMemoryOutOfmemory.java</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;*/</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">public</strong>&nbsp;<strong style="margin:0px;padding:0px;">class</strong>&nbsp;DirectoryMemoryOutOfmemory {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">private</strong>&nbsp;<strong style="margin:0px;padding:0px;">static</strong>&nbsp;<strong style="margin:0px;padding:0px;">final</strong>&nbsp;<strong style="margin:0px;padding:0px;">int</strong>&nbsp;<em style="margin:0px;padding:0px;">ONE_MB</em>&nbsp;= 1024*1024;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">private</strong>&nbsp;<strong style="margin:0px;padding:0px;">static</strong>&nbsp;<strong style="margin:0px;padding:0px;">int</strong>&nbsp;<em style="margin:0px;padding:0px;">count</em>&nbsp;= 1;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; /**</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@param</strong>&nbsp;args</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;<strong style="margin:0px;padding:0px;">@Author</strong>&nbsp;YHJ create at 2011-11-12 下午09:05:54</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; &nbsp;*/</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">public</strong>&nbsp;<strong style="margin:0px;padding:0px;">static</strong>&nbsp;<strong style="margin:0px;padding:0px;">void</strong>&nbsp;main(String[] args) {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">try</strong>&nbsp;{</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Field field = Unsafe.<strong style="margin:0px;padding:0px;">class</strong>.getDeclaredField("theUnsafe");</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; field.setAccessible(<strong style="margin:0px;padding:0px;">true</strong>);</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Unsafe unsafe = (Unsafe) field.get(<strong style="margin:0px;padding:0px;">null</strong>);</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">while</strong>&nbsp;(<strong style="margin:0px;padding:0px;">true</strong>) {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsafe.allocateMemory(<em style="margin:0px;padding:0px;">ONE_MB</em>);</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em style="margin:0px;padding:0px;">count</em>++;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<strong style="margin:0px;padding:0px;">catch</strong>&nbsp;(Exception e) {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.<em style="margin:0px;padding:0px;">out</em>.println("Exception:instance created "+<em style="margin:0px;padding:0px;">count</em>);</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<strong style="margin:0px;padding:0px;">catch</strong>&nbsp;(Error e) {</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.<em style="margin:0px;padding:0px;">out</em>.println("Error:instance created "+<em style="margin:0px;padding:0px;">count</em>);</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;&nbsp;&nbsp; }</p>
<p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">&nbsp;</p>
<div style="margin:0px;padding:0px;"><p align="left" style="margin:10px auto;padding:0px;line-height:1.5;">}</p>
</div>
</div></body></html>