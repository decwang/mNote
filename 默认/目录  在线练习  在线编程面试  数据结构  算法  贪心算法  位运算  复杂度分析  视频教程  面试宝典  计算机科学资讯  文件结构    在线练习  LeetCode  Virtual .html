<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content=mNote Mac 2.5.11"/><meta name="created" content="2017-07-13T05:39:46Z"/><meta name="updated" content="2017-07-13T05:39:48Z"/><title>目录  在线练习  在线编程面试  数据结构  算法  贪心算法  位运算  复杂度分析  视频教程  面试宝典  计算机科学资讯  文件结构    在线练习  LeetCode  Virtual </title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">目录</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">在线练习</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">在线编程面试</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">数据结构</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">算法</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">贪心算法</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">位运算</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">复杂度分析</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">视频教程</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">面试宝典</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">计算机科学资讯</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">文件结构</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">在线练习</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><a href="https://leetcode.com/" style="border:0px;margin:0px;padding:0px;text-decoration:none;color:#0099cc;">LeetCode</a></li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><a href="https://vjudge.net/" style="border:0px;margin:0px;padding:0px;text-decoration:none;color:#0099cc;">Virtual Judge</a></li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><a href="https://www.careercup.com/" style="border:0px;margin:0px;padding:0px;text-decoration:none;color:#0099cc;">CareerCup</a></li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><a href="https://www.hackerrank.com/" style="border:0px;margin:0px;padding:0px;text-decoration:none;color:#0099cc;">HackerRank</a></li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><a href="https://codefights.com/" style="border:0px;margin:0px;padding:0px;text-decoration:none;color:#0099cc;">CodeFights</a></li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><a href="https://open.kattis.com/" style="border:0px;margin:0px;padding:0px;text-decoration:none;color:#0099cc;">Kattis</a></li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><a href="https://www.hackerearth.com/" style="border:0px;margin:0px;padding:0px;text-decoration:none;color:#0099cc;">HackerEarth</a></li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><a href="https://codility.com/programmers/lessons/1-iterations/" style="border:0px;margin:0px;padding:0px;text-decoration:none;color:#0099cc;">Codility</a></li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><a href="http://codeforces.com/" style="border:0px;margin:0px;padding:0px;text-decoration:none;color:#0099cc;">Code Forces</a></li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><a href="https://www.codechef.com/" style="border:0px;margin:0px;padding:0px;text-decoration:none;color:#0099cc;">Code Chef</a></li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><a href="http://www.spoj.com/" style="border:0px;margin:0px;padding:0px;text-decoration:none;color:#0099cc;">Sphere Online Judge – SPOJ</a></li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">在线编程面试</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><a href="http://www.gainlo.co/#!/" style="border:0px;margin:0px;padding:0px;text-decoration:none;color:#0099cc;">Gainlo</a></li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><a href="https://refdash.com/" style="border:0px;margin:0px;padding:0px;text-decoration:none;color:#0099cc;">Refdash</a></li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">数据结构</strong></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">链表</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">链表是一种由节点（Node）组成的线性数据集合，每个节点通过指针指向下一个节点。它是一种由节点组成，并能用于表示序列的数据结构。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><strong style="border:0px;margin:0px;padding:0px;">单链表</strong>：每个节点仅指向下一个节点，最后一个节点指向空（null）。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><strong style="border:0px;margin:0px;padding:0px;">双链表</strong>：每个节点有两个指针p，n。p指向前一个节点，n指向下一个节点；最后一个节点指向空。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><strong style="border:0px;margin:0px;padding:0px;">循环链表</strong>：每个节点指向下一个节点，最后一个节点指向第一个节点。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度：<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">索引：O(n)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">查找：O(n)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">插入：O(1)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">删除：O(1)</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">栈</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">栈是一个元素集合，支持两个基本操作：push用于将元素压入栈，pop用于删除栈顶元素。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">后进先出的数据结构（Last In First Out, LIFO）</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">索引：O(n)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">查找：O(n)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">插入：O(1)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">删除：O(1)</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">队列</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">队列是一个元素集合，支持两种基本操作：enqueue 用于添加一个元素到队列，dequeue 用于删除队列中的一个元素。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">先进先出的数据结构（First In First Out, FIFO）。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">索引：O(n)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">查找：O(n)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">插入：O(1)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">删除：O(1)</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">树</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">树是无向、联通的无环图。</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">二叉树</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">二叉树是一个树形数据结构，每个节点最多可以有两个子节点，称为左子节点和右子节点。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><strong style="border:0px;margin:0px;padding:0px;">满二叉树（Full Tree）</strong>：二叉树中的每个节点有 0 或者 2 个子节点。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><strong style="border:0px;margin:0px;padding:0px;">完美二叉树（Perfect Binary）</strong>：二叉树中的每个节点有两个子节点，并且所有的叶子节点的深度是一样的。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><strong style="border:0px;margin:0px;padding:0px;">完全二叉树</strong>：二叉树中除最后一层外其他各层的节点数均达到最大值，最后一层的节点都连续集中在最左边。</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">二叉查找树</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">二叉查找树（BST）是一种二叉树。其任何节点的值都大于等于左子树中的值，小于等于右子树中的值。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">索引：O(log(n))</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">查找：O(log(n))</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">插入：O(log(n))</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">删除：O(log(n))</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx4.sinaimg.cn/mw690/6941baebly1fehl7rmxs8j20od15ojuu.jpg" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">字典树</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">字典树，又称为基数树或前缀树，是一种用于存储键值为字符串的动态集合或关联数组的查找树。树中的节点并不直接存储关联键值，而是该节点在树中的位置决定了其关联键值。一个节点的所有子节点都有相同的前缀，根节点则是空字符串。</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx1.sinaimg.cn/mw690/6941baebly1fehl7r4nzfj20e80dcgmq.jpg" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">树状数组</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">树状数组，又称为二进制索引树（Binary Indexed Tree，BIT），其概念上是树，但以数组实现。数组中的下标代表树中的节点，每个节点的父节点或子节点的下标可以通过位运算获得。数组中的每个元素都包含了预计算的区间值之和，在整个树更新的过程中，这些计算的值也同样会被更新。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">区间求和：O(log(n))</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">更新：O(log(n))</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx3.sinaimg.cn/mw690/6941baebly1fehl7qs479j20hl0dcjuy.jpg" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">线段树</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">线段树是用于存储区间和线段的树形数据结构。它允许查找一个节点在若干条线段中出现的次数。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">区间查找：O(log(n))</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">更新：O(log(n))</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx4.sinaimg.cn/mw690/6941baebly1fehl7q5vwvj20hs0cdq4n.jpg" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">堆</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">堆是一种基于树的满足某些特性的数据结构：整个堆中的所有父子节点的键值都满足相同的排序条件。堆分为最大堆和最小堆。在最大堆中，父节点的键值永远大于等于所有子节点的键值，根节点的键值是最大的。最小堆中，父节点的键值永远小于等于所有子节点的键值，根节点的键值是最小的。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">索引：O(log(n))</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">查找：O(log(n))</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">插入：O(log(n))</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">删除：O(log(n))</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">删除最大值/最小值：O(1)</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx4.sinaimg.cn/mw690/6941baebly1fehl7pkqxxj20p00w2ju4.jpg" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">哈希</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">哈希用于将任意长度的数据映射到固定长度的数据。哈希函数的返回值被称为哈希值、哈希码或者哈希。如果不同的主键得到相同的哈希值，则发生了冲突。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><strong style="border:0px;margin:0px;padding:0px;">Hash Map</strong>：<em style="border:0px;margin:0px;padding:0px;">hash map</em>&nbsp;是一个存储键值间关系的数据结构。HashMap 通过哈希函数将键转化为桶或者槽中的下标，从而便于指定值的查找。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">冲突解决<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><strong style="border:0px;margin:0px;padding:0px;">链地址法（</strong><strong style="border:0px;margin:0px;padding:0px;">Separate Chaining</strong><strong style="border:0px;margin:0px;padding:0px;">）</strong>：在链地址法中，每个桶（bucket）是相互独立的，每一个索引对应一个元素列表。处理HashMap 的时间就是查找桶的时间（常量）与遍历列表元素的时间之和。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><strong style="border:0px;margin:0px;padding:0px;">开放地址法（</strong><strong style="border:0px;margin:0px;padding:0px;">Open Addressing</strong><strong style="border:0px;margin:0px;padding:0px;">）</strong>：在开放地址方法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个未被占用的地址。开放地址即某个元素的位置并不永远由其哈希值决定。</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx3.sinaimg.cn/mw690/6941baebly1fehl7oz319j20fd0dc402.jpg" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">图</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">图是G =（V，E）的有序对，其包括顶点或节点的集合 V 以及边或弧的集合E，其中E包括了两个来自V的元素（即边与两个顶点相关联 ，并且该关联为这两个顶点的无序对）。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><strong style="border:0px;margin:0px;padding:0px;">无向图</strong>：图的邻接矩阵是对称的，因此如果存在节点 u 到节点 v 的边，那节点 v 到节点 u 的边也一定存在。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><strong style="border:0px;margin:0px;padding:0px;">有向图</strong>：图的邻接矩阵不是对称的。因此如果存在节点 u 到节点 v 的边并不意味着一定存在节点 v 到节点 u 的边。</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx3.sinaimg.cn/mw690/6941baebly1fehl7og3jej20p0133goj.jpg" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">算法</strong></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">排序</strong></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">快速排序</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">稳定：否</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">最优：O(nlog(n))</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">最差：O(n^2)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">平均：O(nlog(n))</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx3.sinaimg.cn/large/6941baebly1fehl7nu4z7g20r107jqnp.gif" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">合并排序</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">合并排序是一种分治算法。这个算法不断地将一个数组分为两部分，分别对左子数组和右子数组排序，然后将两个数组合并为新的有序数组。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">稳定：是</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度：<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">最优：O(nlog(n))</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">最差：O(nlog(n))</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">平均：O(nlog(n))</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx4.sinaimg.cn/large/6941baebly1fehl7icnjzg20hs0aokjn.gif" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">桶排序</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">桶排序是一种将元素分到一定数量的桶中的排序算法。每个桶内部采用其他算法排序，或递归调用桶排序。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">最优：Ω(n + k)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">最差: O(n^2)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">平均：Θ(n + k)</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx4.sinaimg.cn/mw690/6941baebly1fehl7k0qx4j20hs07k75q.jpg" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">基数排序</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">基数排序类似于桶排序，将元素分发到一定数目的桶中。不同的是，基数排序在分割元素之后没有让每个桶单独进行排序，而是直接做了合并操作。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">最优：Ω(nk)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">最差: O(nk)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">平均：Θ(nk)</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">图算法</strong></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">深度优先</strong><strong style="border:0px;margin:0px;padding:0px;">搜索</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">深度优先搜索是一种先遍历子节点而不回溯的图遍历算法。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度：O(|V| + |E|)</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx1.sinaimg.cn/mw690/6941baebly1fehl7jf9xtg20hs09974o.gif" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">广度优先</strong><strong style="border:0px;margin:0px;padding:0px;">搜索</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">广度优先搜索是一种先遍历邻居节点而不是子节点的图遍历算法。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度：O(|V| + |E|)</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx4.sinaimg.cn/mw690/6941baebly1fehl7iwu8hg20hs09974o.gif" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">拓扑排序</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">拓扑排序是有向图节点的线性排序。对于任何一条节点 u 到节点 v 的边，u 的下标先于 v。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度：O(|V| + |E|)</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">Dijkstra算法</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">Dijkstra 算法是一种在有向图中查找单源最短路径的算法。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度：O(|V|^2)</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx1.sinaimg.cn/mw690/6941baebly1fehl77perwg20li09atbg.gif" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">Bellman-Ford算法</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><em style="border:0px;margin:0px;padding:0px;">Bellman-Ford&nbsp;</em>是一种在带权图中查找单一源点到其他节点最短路径的算法。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">虽然时间复杂度大于 Dijkstra 算法，但它可以处理包含了负值边的图。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度：<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">最优：O(|E|)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">最差：O(|V||E|)</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx3.sinaimg.cn/mw690/6941baebly1fehl771hlsg20kr079438.gif" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">Floyd-Warshall 算法</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><em style="border:0px;margin:0px;padding:0px;">Floyd-Warshall&nbsp;</em>算法是一种在无环带权图中寻找任意节点间最短路径的算法。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">该算法执行一次即可找到所有节点间的最短路径（路径权重和）。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度：<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">最优：O(|V|^3)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">最差：O(|V|^3)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">平均：O(|V|^3)</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">最小生成树算法</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">最小生成树算法是一种在无向带权图中查找最小生成树的贪心算法。换言之，最小生成树算法能在一个图中找到连接所有节点的边的最小子集。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度：O(|V|^2)</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx1.sinaimg.cn/mw690/6941baebly1fehl76ellbg208q08zago.gif" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">Kruskal 算法</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;"><em style="border:0px;margin:0px;padding:0px;">Kruskal&nbsp;</em>算法也是一个计算最小生成树的贪心算法，但在 Kruskal 算法中，图不一定是连通的。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">时间复杂度：O(|E|log|V|)</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx1.sinaimg.cn/mw690/6941baebly1fehl75byw0g208q08zgwv.gif" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">贪心算法</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">贪心算法总是做出在当前看来最优的选择，并希望最后整体也是最优的。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">使用贪心算法可以解决的问题必须具有如下两种特性：<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">最优子结构<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style:circle outside;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">问题的最优解包含其子问题的最优解。</li>
</ul>
</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">贪心选择<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style:circle outside;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">每一步的贪心选择可以得到问题的整体最优解。</li>
</ul>
</li>
</ul>
</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">实例-硬币选择问题</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">给定期望的硬币总和为 V 分，以及 n 种硬币，即类型是 i 的硬币共有 coinValue[i] 分，i的范围是 [0…n – 1]。假设每种类型的硬币都有无限个，求解为使和为 V 分最少需要多少硬币？</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">硬币：便士（1美分），镍（5美分），一角（10美分），四分之一（25美分）。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">假设总和 V 为41,。我们可以使用贪心算法查找小于或者等于 V 的面值最大的硬币，然后从 V 中减掉该硬币的值，如此重复进行。<ul style="border:0px;margin:0px 0px 0px 20px;padding:0px;list-style-position:outside;list-style-image:initial;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">V = 41 | 使用了0个硬币</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">V = 16 | 使用了1个硬币(41 – 25 = 16)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">V = 6 | 使用了2个硬币(16 – 10 = 6)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">V = 1 | 使用了3个硬币(6 – 5 = 1)</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">V = 0 | 使用了4个硬币(1 – 1 = 0)</li>
</ul>
</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">位</strong><strong style="border:0px;margin:0px;padding:0px;">运算</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">位运算即在比特级别进行操作的技术。使用位运算技术可以带来更快的运行速度与更小的内存使用。</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">测试第 k 位：s &amp; (1 &lt;&lt; k);</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">设置第k位：s |= (1 &lt;&lt; k);</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">关闭第k位：s &amp;= ~(1 &lt;&lt; k);</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">切换第k位：s ^= (1 &lt;&lt; k);</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">乘以2n：s &lt;&lt; n;</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">除以2n：s &gt;&gt; n;</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">交集：s &amp; t;</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">并集：s | t;</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">减法：s &amp; ~t;</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">提取最小非0位：s &amp; (-s);</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">提取最小0位：~s &amp; (s + 1);</li>
<li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">交换值：x ^= y; y ^= x; x ^= y;</li>
</ul>
<h1 style="border:0px;margin:0px 0px 20px;padding:0px;font-size:26px;font-variant-ligatures:normal;font-variant-east-asian:normal;font-variant-position:normal;font-stretch:normal;line-height:40px;font-family:'Microsoft YaHei', 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;color:#2e2e2e;orphans:2;widows:2;">运行时分析</h1>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">大 O 表示</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">大 O 表示用于表示某个算法的上界，用于描述最坏的情况。</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx4.sinaimg.cn/mw690/6941baebly1fehl74ftayj20hs0dc0sn.jpg" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">小 O 表示</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">小 O 表示用于描述某个算法的渐进上界，二者逐渐趋近。</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">大 Ω 表示</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">大 Ω 表示用于描述某个算法的渐进下界。</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx1.sinaimg.cn/mw690/6941baebly1fehl7409jrj20hs0dcjr9.jpg" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">小 ω 表示</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">小 ω 表示用于描述某个算法的渐进下界，二者逐渐趋近。</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">Theta Θ 表示</strong></p>
<ul style="border:0px;margin:0px 0px 20px;padding:0px;font-size:15px;list-style-position:outside;list-style-image:initial;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="border:0px;margin:0px 0px 5px 30px;padding:0px;">Theta Θ 表示用于描述某个算法的确界，包括最小上界和最大下界。</li>
</ul>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img src="http://wx4.sinaimg.cn/mw690/6941baebly1fehl73k2kmj20hs0dc3yg.jpg" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><strong style="border:0px;margin:0px;padding:0px;">以为这就结束了？No, 这些知识不仅仅是停留在理论，还有代码实现。</strong></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;">&nbsp;</p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><img class="alignnone" src="http://wx4.sinaimg.cn/mw690/63918611gy1feq19n1ig5j20br24bn79.jpg" width="423" height="2747" style="border:0px;margin:auto;padding:0px;font-size:0px;color:transparent;vertical-align:middle;height:auto;display:block;clear:both;" /></p>
<p style="border:0px;margin-top:0px;margin-bottom:20px;padding:0px;font-size:15px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;">这其实是来自 GitHub 的一个 repo：<a href="https://github.com/kdn251/interviews" target="_blank" style="border:0px;margin:0px;padding:0px;text-decoration:none;color:#0099cc;">https://github.com/kdn251/interviews</a></p></body></html>