<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content=mNote Mac 2.5.11"/><meta name="created" content="2017-07-14T04:24:55Z"/><meta name="updated" content="2017-07-14T04:25:03Z"/><title>缓存击穿、失效以及热点key问题</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><h1 class="title" style="box-sizing:border-box;font-size:34px;margin:20px 0px 0px;font-family:-apple-system, 'SF UI Display', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;line-height:1.3;color:#333333;word-break:break-word;font-variant-ligatures:normal;orphans:2;widows:2;">缓存击穿、失效以及热点key问题</h1>
<div class="author" style="box-sizing:border-box;margin:30px 0px 40px;color:#333333;font-family:-apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;font-size:17px;font-variant-ligatures:normal;orphans:2;widows:2;"><a class="avatar" href="http://www.jianshu.com/u/6022b4d863cd" style="box-sizing:border-box;background-color:transparent;color:#333333;text-decoration:none;cursor:pointer;width:48px;height:48px;display:inline-block;vertical-align:middle;"><img src="http://upload.jianshu.io/users/upload_avatars/616903/7bc410c8f43d.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/144/h/144" alt="144" style="box-sizing:border-box;border:1px solid #dddddd;vertical-align:middle;width:48px;height:48px;border-radius:50%;" /></a>&nbsp;<div class="info" style="box-sizing:border-box;vertical-align:middle;display:inline-block;margin-left:8px;"><span class="tag" style="box-sizing:border-box;padding:1px 2px;font-size:12px;color:#ea6f5a;border:1px solid #ea6f5a;border-radius:3px;">作者</span>&nbsp;<span class="name" style="box-sizing:border-box;margin-left:3px;margin-right:3px;font-size:16px;vertical-align:middle;"><a href="http://www.jianshu.com/u/6022b4d863cd" style="box-sizing:border-box;background-color:transparent;color:#333333;text-decoration:none;cursor:pointer;">MavericksJi</a></span>&nbsp;<a class="btn btn-success follow" style="box-sizing:border-box;background-color:#42c02e;color:#ffffff;cursor:pointer;display:inline-block;margin-bottom:0px;text-align:center;vertical-align:middle;background-image:none;border:1px solid #42c02e;white-space:nowrap;padding:0px 7px 0px 5px;font-size:12px;line-height:normal;border-top-left-radius:40px;border-top-right-radius:40px;border-bottom-right-radius:40px;border-bottom-left-radius:40px;"><span style="box-sizing:border-box;margin-left:2px;">关注</span></a><div class="meta" style="box-sizing:border-box;margin-top:5px;font-size:12px;color:#969696;"><span class="publish-time" data-toggle="tooltip" data-placement="bottom" title="" data-original-title="最后编辑于 2017.01.12 23:05" style="box-sizing:border-box;padding-right:5px;">2017.01.11 16:56*</span>&nbsp;<span class="wordage" style="box-sizing:border-box;padding-right:5px;">字数 1010</span>&nbsp;<span class="views-count" style="box-sizing:border-box;padding-right:5px;">阅读 698</span><span class="comments-count" style="box-sizing:border-box;padding-right:5px;">评论 3</span><span class="likes-count" style="box-sizing:border-box;padding-right:5px;">喜欢 10</span></div>
</div>
</div>
<div data-note-content="" class="show-content" style="box-sizing:border-box;color:#2f2f2f;word-break:break-word;font-size:16px;line-height:1.7;font-family:-apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">　　分布式缓存是网站服务端经常用到的一种技术，在读多写少的业务场景中，通过使用缓存可以有效地支撑高并发的访问量，对后端的数据库等数据源做到很好地保护。现在市面上有很多分布式缓存，比如Redis、Memcached以及阿里的Tair等，不管我们使用的哪种缓存产品，基本上都会遇到缓存击穿、缓存失效以及热点key的问题。如何有效地防止这些问题，也是我们在享受缓存带来的红利地同时，必须要解决地难题。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">　　通常我们在使用缓存时候都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回，例如下图所示，<br style="box-sizing:border-box;" />
</p>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/616903-4f6c97a3c449734b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/616903-4f6c97a3c449734b.png?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
<div class="image-caption" style="box-sizing:border-box;min-width:20%;max-width:80%;min-height:22px;display:inline-block;padding:10px;margin:0px auto;border-bottom:1px solid #d9d9d9;font-size:14px;color:#969696;line-height:1.7;">缓存使用.png</div>
</div>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><span style="box-sizing:border-box;font-weight:700;">缓存击穿：</span><br style="box-sizing:border-box;" />
　　查询一个数据库中不存在的数据，比如商品详情，查询一个不存在的ID，每次都会访问DB，如果有人恶意破坏，很可能直接对DB造成过大地压力。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><span style="box-sizing:border-box;font-weight:700;">缓存击穿的解决方案：</span><br style="box-sizing:border-box;" />
　　当通过某一个key去查询数据的时候，如果对应在数据库中的数据都不存在，我们将此key对应的value设置为一个默认的值，比如“NULL”，并设置一个缓存的失效时间，这时在缓存失效之前，所有通过此key的访问都被缓存挡住了。后面如果此key对应的数据在DB中存在时，缓存失效之后，通过此key再去访问数据，就能拿到新的value了。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><span style="box-sizing:border-box;font-weight:700;">缓存失效：</span><br style="box-sizing:border-box;" />
　　在高并发的环境下，如果此时key对应的缓存失效，此时有多个进程就会去同时去查询DB，然后再去同时设置缓存。这个时候如果这个key是系统中的热点key或者同时失效的数量比较多时，DB访问量会瞬间增大，造成过大的压力。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><span style="box-sizing:border-box;font-weight:700;">缓存失效的解决方案：</span></p>
<ul style="box-sizing:border-box;margin-top:0px;margin-bottom:20px;padding:0px;word-break:break-word;margin-left:22px;"><li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">将系统中key的缓存失效时间均匀地错开，防止统一时间点有大量的key对应的缓存失效；</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">重新设计缓存的使用方式，当我们通过key去查询数据时，首先查询缓存，如果此时缓存中查询不到，就通过分布式锁进行加锁，取得锁的进程查DB并设置缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回缓存数据或者再次查询DB。</li>
</ul>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><span style="box-sizing:border-box;font-weight:700;">热点key：</span><br style="box-sizing:border-box;" />
　　缓存中的某些Key(可能对应用与某个促销商品)对应的value存储在集群中一台机器，使得所有流量涌向同一机器，成为系统的瓶颈，该问题的挑战在于它无法通过增加机器容量来解决。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><span style="box-sizing:border-box;font-weight:700;">热点key的解决方案：</span></p>
<ul style="box-sizing:border-box;margin-top:0px;margin-bottom:20px;padding:0px;word-break:break-word;margin-left:22px;"><li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">客户端热点key缓存：将热点key对应value并缓存在客户端本地，并且设置一个失效时间。对于每次读请求，将首先检查key是否存在于本地缓存中，如果存在则直接返回，如果不存在再去访问分布式缓存的机器。</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">将热点key分散为多个子key，然后存储到缓存集群的不同机器上，这些子key对应的value都和热点key是一样的。当通过热点key去查询数据时，通过某种hash算法随机选择一个子key，然后再去访问缓存机器，将热点分散到了多个子key上。</li>
</ul>
</div></body></html>