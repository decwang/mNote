<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content=mNote Mac 2.5.11"/><meta name="created" content="2016-11-01T04:18:59Z"/><meta name="updated" content="2016-11-01T04:19:01Z"/><title>iOS事件响应链中Hit-Test View的应用  字数1755 阅读3857 评论3 喜欢23  最近又看了遍苹果的官方文档《Event Handling Guide for iOS》，对事件响</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><h1 class="title" style="margin:10px 0px;font-family:-apple-system, 'Helvetica Neue', Arial, 'PingFang SC', 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;line-height:1.5;color:#555555;text-rendering:optimizelegibility;font-size:32px;word-break:break-all;">iOS事件响应链中Hit-Test View的应用</h1>
<div class="meta-top" style="font-family:-apple-system, 'Helvetica Neue', Arial, 'PingFang SC', 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;margin:20px 0px;color:#555555;"><span class="wordage" style="position:relative;top:1px;margin-right:10px;font-size:12px;color:#999999;">字数1755</span>&nbsp;<span class="views-count" style="position:relative;top:1px;margin-right:10px;font-size:12px;color:#999999;">阅读3857</span>&nbsp;<span class="comments-count" style="position:relative;top:1px;margin-right:10px;font-size:12px;color:#999999;">评论3</span>&nbsp;<span class="likes-count" style="position:relative;top:1px;margin-right:10px;font-size:12px;color:#999999;">喜欢23</span></div>
<div class="show-content" style="color:#2f2f2f;font-size:16px;line-height:1.7;font-family:-apple-system, 'Helvetica Neue', Arial, 'PingFang SC', 'lucida grande', 'lucida sans unicode', lucida, helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;"><p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">最近又看了遍苹果的官方文档<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html" target="_blank" style="color:#4094c7;text-decoration:none;">《Event Handling Guide for iOS》</a>，对事件响应链中的<strong>hit-test view</strong>&nbsp;又多了些理解，个人觉的官方文档对这块讲的非常简单，很多东西都是点到为止，<strong>hit-test view</strong>的知识在项目的任何地方都用到了，但自己反而感知不到，接下来我会给大家讲<strong>hit-test view</strong>的项目中能解决痛点的三个应用 。</p>
<p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">什么叫&nbsp;<strong>hit-test view</strong>？文档说：<em>The lowest view in the view hierarchy that contains the touch point becomes the hit-test view</em>，我的理解是：当你点击了屏幕上的某个view，这个动作由硬件层传导到操作系统，然后又从底层封装成一个事件（Event）顺着view的层级往上传导，一直要找到含有这个点击点<strong>且</strong>层级最高（文档说是最低，我理解是逻辑上最靠近手指）的view来响应事件，这个view就是<strong>hit-test view</strong>。</p>
<p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">文档中说，决定谁<strong>hit-test view</strong>是通过不断递归调用view中的&nbsp;<em>- (UIView *)hitTest: withEvent:</em>&nbsp;方法和&nbsp;<em>-(BOOL)pointInside: withEvent:</em>&nbsp;方法来实现的，文段中的这段话太好理解，于是我仿照官方文档中这张图做了个Demo -&gt;&nbsp;<a href="https://github.com/slemon/HitTestViewUsage" target="_blank" style="color:#4094c7;text-decoration:none;">Github地址</a></p>
<div class="image-package imagebubble" widget="ImageBubble" style="margin:0px auto 20px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/144142-3afc2c85792ade41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/144142-3afc2c85792ade41.png?imageMogr2/auto-orient/strip%7CimageView2/2" class="imagebubble-image" style="height:auto;vertical-align:middle;border:0px;cursor:-webkit-zoom-in;-webkit-transition:all 0.25s ease-in-out;transition:all 0.25s ease-in-out;" /><br />
<div class="image-caption" style="min-width:20%;min-height:22px;display:inline-block;padding:10px;margin:0px auto;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#d9d9d9;font-size:13px;color:#999999;font-style:italic;line-height:1.7;">apple doucument pic</div>
</div>
<p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">重载图中view的方法添加相应的log便于观察：</p>
<pre class="hljs objectivec" style="padding:9.5px;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;color:#657b83;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:4px;border-bottom-left-radius:4px;margin-top:0px;margin-bottom:20px;line-height:20px;word-break:break-all;word-wrap:normal;background-color:#fdf6e3;border:1px solid rgba(0, 0, 0, 0.14902);overflow:auto;"><code class="objectivec" style="padding:0px;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;border-top-left-radius:3px;border-top-right-radius:3px;border-bottom-right-radius:3px;border-bottom-left-radius:3px;background-color:transparent;border:none;"><span class="hljs-comment" style="color:#93a1a1;">//in every view .m overide those methods</span> - (<span class="hljs-built_in" style="color:#268bd2;">UIView</span> *)hitTest:(<span class="hljs-built_in" style="color:#268bd2;">CGPoint</span>)point withEvent:(<span class="hljs-built_in" style="color:#268bd2;">UIEvent</span> *)event {
    <span class="hljs-built_in" style="color:#268bd2;">NSLog</span>(<span class="hljs-string" style="color:#2aa198;">@"进入A_View---hitTest withEvent ---"</span>);
    <span class="hljs-built_in" style="color:#268bd2;">UIView</span> * view = [<span class="hljs-keyword" style="color:#859900;">super</span> hitTest:point withEvent:event];
    <span class="hljs-built_in" style="color:#268bd2;">NSLog</span>(<span class="hljs-string" style="color:#2aa198;">@"离开A_View--- hitTest withEvent ---hitTestView:%@"</span>,view);
    <span class="hljs-keyword" style="color:#859900;">return</span> view;
}

- (<span class="hljs-built_in" style="color:#268bd2;">BOOL</span>)pointInside:(<span class="hljs-built_in" style="color:#268bd2;">CGPoint</span>)point withEvent:(nullable <span class="hljs-built_in" style="color:#268bd2;">UIEvent</span> *)event {
    <span class="hljs-built_in" style="color:#268bd2;">NSLog</span>(<span class="hljs-string" style="color:#2aa198;">@"A_view--- pointInside withEvent ---"</span>);
    <span class="hljs-built_in" style="color:#268bd2;">BOOL</span> isInside = [<span class="hljs-keyword" style="color:#859900;">super</span> pointInside:point withEvent:event];
    <span class="hljs-built_in" style="color:#268bd2;">NSLog</span>(<span class="hljs-string" style="color:#2aa198;">@"A_view--- pointInside withEvent --- isInside:%d"</span>,isInside);
    <span class="hljs-keyword" style="color:#859900;">return</span> isInside;
}

- (<span class="hljs-keyword" style="color:#859900;">void</span>)touchesBegan:(<span class="hljs-built_in" style="color:#268bd2;">NSSet</span> *)touches withEvent:(<span class="hljs-built_in" style="color:#268bd2;">UIEvent</span> *)event
{
    <span class="hljs-built_in" style="color:#268bd2;">NSLog</span>(<span class="hljs-string" style="color:#2aa198;">@"A_touchesBegan"</span>);
}

- (<span class="hljs-keyword" style="color:#859900;">void</span>)touchesMoved:(<span class="hljs-built_in" style="color:#268bd2;">NSSet</span>&lt;<span class="hljs-built_in" style="color:#268bd2;">UITouch</span> *&gt; *)touches withEvent:(nullable <span class="hljs-built_in" style="color:#268bd2;">UIEvent</span> *)event {
    <span class="hljs-built_in" style="color:#268bd2;">NSLog</span>(<span class="hljs-string" style="color:#2aa198;">@"A_touchesMoved"</span>);
}

- (<span class="hljs-keyword" style="color:#859900;">void</span>)touchesEnded:(<span class="hljs-built_in" style="color:#268bd2;">NSSet</span>&lt;<span class="hljs-built_in" style="color:#268bd2;">UITouch</span> *&gt; *)touches withEvent:(nullable <span class="hljs-built_in" style="color:#268bd2;">UIEvent</span> *)event {
    <span class="hljs-built_in" style="color:#268bd2;">NSLog</span>(<span class="hljs-string" style="color:#2aa198;">@"A_touchesEnded"</span>);
}</code></pre><p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">点击图中View_D，看下会发生什么</p>
<div class="image-package imagebubble" widget="ImageBubble" style="margin:0px auto 20px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/144142-9850f716526bb4e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/144142-9850f716526bb4e8.png?imageMogr2/auto-orient/strip%7CimageView2/2" class="imagebubble-image" style="height:auto;vertical-align:middle;border:0px;cursor:-webkit-zoom-in;-webkit-transition:all 0.25s ease-in-out;transition:all 0.25s ease-in-out;" /><br />
<div class="image-caption" style="min-width:20%;min-height:22px;display:inline-block;padding:10px;margin:0px auto;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#d9d9d9;font-size:13px;color:#999999;font-style:italic;line-height:1.7;">View_D log</div>
</div>
<p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">一是发现<em>touchesBegan、touchesMoved、touchesEnded</em>这些方法都是发生在找到<strong>hit-test view</strong>之后，因为touch事件是针对能响应事件的确定的某个view，比如你手指划出了scrollview的范围，只要你不松手继续滑动，scrollview依然会响应滑动事件继续滚动；二是寻找<strong>hit-test view</strong>的事件链传导了两遍，而且两次的调用堆栈是不同的，这点我有点搞不懂，为啥需要两遍，查阅了很多资料也不知道原因，发现真机和模拟器以及不同的系统版本之间还会有些区别（此为真机iOS9），大家可以下载我的<a href="https://github.com/slemon/HitTestViewUsage" target="_blank" style="color:#4094c7;text-decoration:none;">Demo</a>进行测试与研究。</p>
<p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">把这个寻找的逻辑换成代码如下:</p>
<pre class="hljs objectivec" style="padding:9.5px;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;color:#657b83;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:4px;border-bottom-left-radius:4px;margin-top:0px;margin-bottom:20px;line-height:20px;word-break:break-all;word-wrap:normal;background-color:#fdf6e3;border:1px solid rgba(0, 0, 0, 0.14902);overflow:auto;"><code class="objectivec" style="padding:0px;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;border-top-left-radius:3px;border-top-right-radius:3px;border-bottom-right-radius:3px;border-bottom-left-radius:3px;background-color:transparent;border:none;">- (<span class="hljs-built_in" style="color:#268bd2;">UIView</span> *)hitTest:(<span class="hljs-built_in" style="color:#268bd2;">CGPoint</span>)point withEvent:(<span class="hljs-built_in" style="color:#268bd2;">UIEvent</span> *)event {
    <span class="hljs-keyword" style="color:#859900;">if</span> (!<span class="hljs-keyword" style="color:#859900;">self</span><span class="hljs-variable" style="color:#b58900;">.isUserInteractionEnabled</span> || <span class="hljs-keyword" style="color:#859900;">self</span><span class="hljs-variable" style="color:#b58900;">.isHidden</span> || <span class="hljs-keyword" style="color:#859900;">self</span><span class="hljs-variable" style="color:#b58900;">.alpha</span> &lt;= <span class="hljs-number" style="color:#2aa198;">0.01</span>) {
        <span class="hljs-keyword" style="color:#859900;">return</span> <span class="hljs-literal">nil</span>;
    }
    <span class="hljs-keyword" style="color:#859900;">if</span> ([<span class="hljs-keyword" style="color:#859900;">self</span> pointInside:point withEvent:event]) {
        <span class="hljs-keyword" style="color:#859900;">for</span> (<span class="hljs-built_in" style="color:#268bd2;">UIView</span> *subview <span class="hljs-keyword" style="color:#859900;">in</span> [<span class="hljs-keyword" style="color:#859900;">self</span><span class="hljs-variable" style="color:#b58900;">.subviews</span> reverseObjectEnumerator]) {
            <span class="hljs-built_in" style="color:#268bd2;">CGPoint</span> convertedPoint = [subview convertPoint:point fromView:<span class="hljs-keyword" style="color:#859900;">self</span>];
            <span class="hljs-built_in" style="color:#268bd2;">UIView</span> *hitTestView = [subview hitTest:convertedPoint withEvent:event];
            <span class="hljs-keyword" style="color:#859900;">if</span> (hitTestView) {
                <span class="hljs-keyword" style="color:#859900;">return</span> hitTestView;
            }
        }
        <span class="hljs-keyword" style="color:#859900;">return</span> <span class="hljs-keyword" style="color:#859900;">self</span>;
    }
    <span class="hljs-keyword" style="color:#859900;">return</span> <span class="hljs-literal">nil</span>;
}</code></pre><p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">如果有某个view的两个子view位置重叠，根据<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/WindowsandViews/WindowsandViews.html#//apple_ref/doc/uid/TP40009503-CH2-SW24" target="_blank" style="color:#4094c7;text-decoration:none;">View Programming Guide for iOS</a>文档中说的&nbsp;<em>Visually, the content of a subview obscures all or part of the content of its parent view. If the subview is totally opaque, then the area occupied by the subview completely obscures the corresponding area of the parent. If the subview is partially transparent, the content from the two views is blended together prior to being displayed on the screen. Each superview stores its subviews in an ordered array and the order in that array also affects the visibility of each subview. If two sibling subviews overlap each other, the one that was added last (or was moved to the end of the subview array) appears on top of the other.</em>&nbsp;那最高层（逻辑最靠近手指的）view是view subviews数组的最后一个元素，只要寻找是从数组的第一个元素开始遍历，hit-test view的逻辑依然是有效的。</p>
<p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">找到<strong>hit-test view</strong>后，它会有最高的优先权去响应逐级传递上来的Event，如它不能响应就会传递给它的superview，依此类推，一直传递到UIApplication都无响应者，这个Event就会被系统丢弃了。</p>
<h2 style="margin:0px;font-family:inherit;line-height:1.8;color:inherit;text-rendering:optimizelegibility;font-size:24px;">Hit-test view的应用举例：</h2>
<h3 style="margin:0px;font-family:inherit;line-height:1.8;color:inherit;text-rendering:optimizelegibility;font-size:22px;">1、扩大UIButton的响应热区</h3>
<p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">相信大家都遇到小图button点击热区太小问题，之前我是用UIButton的<em>setImage</em>方法来设置图片解决，但是调起坐标就坑了，得各种计算不说，写出的代码还很难看不便于维护，如果我们用用<em>hit-test view</em>的知识你就能轻松地解决这个问题。</p>
<p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">重载UIButton的<em>-(BOOL)pointInside: withEvent:</em>方法，让Point即使落在Button的Frame外围也返回YES。</p>
<pre class="hljs objectivec" style="padding:9.5px;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;color:#657b83;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:4px;border-bottom-left-radius:4px;margin-top:0px;margin-bottom:20px;line-height:20px;word-break:break-all;word-wrap:normal;background-color:#fdf6e3;border:1px solid rgba(0, 0, 0, 0.14902);overflow:auto;"><code class="objectivec" style="padding:0px;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;border-top-left-radius:3px;border-top-right-radius:3px;border-bottom-right-radius:3px;border-bottom-left-radius:3px;background-color:transparent;border:none;"><span class="hljs-comment" style="color:#93a1a1;">//in custom button .m</span> <span class="hljs-comment" style="color:#93a1a1;">//overide this method</span> - (<span class="hljs-built_in" style="color:#268bd2;">BOOL</span>)pointInside:(<span class="hljs-built_in" style="color:#268bd2;">CGPoint</span>)point withEvent:(nullable <span class="hljs-built_in" style="color:#268bd2;">UIEvent</span> *)event {
    <span class="hljs-keyword" style="color:#859900;">return</span> <span class="hljs-built_in" style="color:#268bd2;">CGRectContainsPoint</span>(HitTestingBounds(<span class="hljs-keyword" style="color:#859900;">self</span><span class="hljs-variable" style="color:#b58900;">.bounds</span>, <span class="hljs-keyword" style="color:#859900;">self</span><span class="hljs-variable" style="color:#b58900;">.minimumHitTestWidth</span>, <span class="hljs-keyword" style="color:#859900;">self</span><span class="hljs-variable" style="color:#b58900;">.minimumHitTestHeight</span>), point);
}<span class="hljs-built_in" style="color:#268bd2;">CGRect</span> HitTestingBounds(<span class="hljs-built_in" style="color:#268bd2;">CGRect</span> bounds, <span class="hljs-built_in" style="color:#268bd2;">CGFloat</span> minimumHitTestWidth, <span class="hljs-built_in" style="color:#268bd2;">CGFloat</span> minimumHitTestHeight) {
    <span class="hljs-built_in" style="color:#268bd2;">CGRect</span> hitTestingBounds = bounds;
    <span class="hljs-keyword" style="color:#859900;">if</span> (minimumHitTestWidth &gt; bounds<span class="hljs-variable" style="color:#b58900;">.size</span><span class="hljs-variable" style="color:#b58900;">.width</span>) {
        hitTestingBounds<span class="hljs-variable" style="color:#b58900;">.size</span><span class="hljs-variable" style="color:#b58900;">.width</span> = minimumHitTestWidth;
        hitTestingBounds<span class="hljs-variable" style="color:#b58900;">.origin</span><span class="hljs-variable" style="color:#b58900;">.x</span> -= (hitTestingBounds<span class="hljs-variable" style="color:#b58900;">.size</span><span class="hljs-variable" style="color:#b58900;">.width</span> - bounds<span class="hljs-variable" style="color:#b58900;">.size</span><span class="hljs-variable" style="color:#b58900;">.width</span>)/<span class="hljs-number" style="color:#2aa198;">2</span>;
    }
    <span class="hljs-keyword" style="color:#859900;">if</span> (minimumHitTestHeight &gt; bounds<span class="hljs-variable" style="color:#b58900;">.size</span><span class="hljs-variable" style="color:#b58900;">.height</span>) {
        hitTestingBounds<span class="hljs-variable" style="color:#b58900;">.size</span><span class="hljs-variable" style="color:#b58900;">.height</span> = minimumHitTestHeight;
        hitTestingBounds<span class="hljs-variable" style="color:#b58900;">.origin</span><span class="hljs-variable" style="color:#b58900;">.y</span> -= (hitTestingBounds<span class="hljs-variable" style="color:#b58900;">.size</span><span class="hljs-variable" style="color:#b58900;">.height</span> - bounds<span class="hljs-variable" style="color:#b58900;">.size</span><span class="hljs-variable" style="color:#b58900;">.height</span>)/<span class="hljs-number" style="color:#2aa198;">2</span>;
    }
    <span class="hljs-keyword" style="color:#859900;">return</span> hitTestingBounds;
}</code></pre><h3 style="margin:0px;font-family:inherit;line-height:1.8;color:inherit;text-rendering:optimizelegibility;font-size:22px;">2、子view超出了父view的bounds响应事件</h3>
<p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">项目中常常遇到button已经超出了父view的范围但仍需可点击的情况，比如自定义Tabbar中间的大按钮，如下图闲鱼的app，点击超出Tabbar bounds的区域也需要响应，此时重载父view的<em>-(UIView *)hitTest: withEvent:</em>方法，去掉点击必须在父view内的判断，然后子view就能成为&nbsp;<strong>hit-test view</strong>用于响应事件了。</p>
<div class="image-package imagebubble" widget="ImageBubble" style="margin:0px auto 20px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/144142-3b8eacb1afb47c93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/144142-3b8eacb1afb47c93.png?imageMogr2/auto-orient/strip%7CimageView2/2" class="imagebubble-image" style="height:auto;vertical-align:middle;border:0px;cursor:-webkit-zoom-in;-webkit-transition:all 0.25s ease-in-out;transition:all 0.25s ease-in-out;" /><br />
<div class="image-caption" style="min-width:20%;min-height:22px;display:inline-block;padding:10px;margin:0px auto;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#d9d9d9;font-size:13px;color:#999999;font-style:italic;line-height:1.7;">xiansyu</div>
</div>
<pre class="hljs objectivec" style="padding:9.5px;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;color:#657b83;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:4px;border-bottom-left-radius:4px;margin-top:0px;margin-bottom:20px;line-height:20px;word-break:break-all;word-wrap:normal;background-color:#fdf6e3;border:1px solid rgba(0, 0, 0, 0.14902);overflow:auto;"><code class="objectivec" style="padding:0px;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;border-top-left-radius:3px;border-top-right-radius:3px;border-bottom-right-radius:3px;border-bottom-left-radius:3px;background-color:transparent;border:none;">- (<span class="hljs-built_in" style="color:#268bd2;">UIView</span> *)hitTest:(<span class="hljs-built_in" style="color:#268bd2;">CGPoint</span>)point withEvent:(<span class="hljs-built_in" style="color:#268bd2;">UIEvent</span> *)event {

    <span class="hljs-keyword" style="color:#859900;">if</span> (!<span class="hljs-keyword" style="color:#859900;">self</span><span class="hljs-variable" style="color:#b58900;">.isUserInteractionEnabled</span> || <span class="hljs-keyword" style="color:#859900;">self</span><span class="hljs-variable" style="color:#b58900;">.isHidden</span> || <span class="hljs-keyword" style="color:#859900;">self</span><span class="hljs-variable" style="color:#b58900;">.alpha</span> &lt;= <span class="hljs-number" style="color:#2aa198;">0.01</span>) {
        <span class="hljs-keyword" style="color:#859900;">return</span> <span class="hljs-literal">nil</span>;
    }
    <span class="hljs-comment" style="color:#93a1a1;">/**
     *  此注释掉的方法用来判断点击是否在父View Bounds内，
     *  如果不在父view内，就会直接不会去其子View中寻找HitTestView，return 返回
     */</span> <span class="hljs-comment" style="color:#93a1a1;">//    if ([self pointInside:point withEvent:event]) {</span>         <span class="hljs-keyword" style="color:#859900;">for</span> (<span class="hljs-built_in" style="color:#268bd2;">UIView</span> *subview <span class="hljs-keyword" style="color:#859900;">in</span> [<span class="hljs-keyword" style="color:#859900;">self</span><span class="hljs-variable" style="color:#b58900;">.subviews</span> reverseObjectEnumerator]) {
            <span class="hljs-built_in" style="color:#268bd2;">CGPoint</span> convertedPoint = [subview convertPoint:point fromView:<span class="hljs-keyword" style="color:#859900;">self</span>];
            <span class="hljs-built_in" style="color:#268bd2;">UIView</span> *hitTestView = [subview hitTest:convertedPoint withEvent:event];
            <span class="hljs-keyword" style="color:#859900;">if</span> (hitTestView) {
                <span class="hljs-keyword" style="color:#859900;">return</span> hitTestView;
            }
        }
        <span class="hljs-keyword" style="color:#859900;">return</span> <span class="hljs-keyword" style="color:#859900;">self</span>;<span class="hljs-comment" style="color:#93a1a1;">//    }</span>     <span class="hljs-keyword" style="color:#859900;">return</span> <span class="hljs-literal">nil</span>;
}</code></pre><h3 style="margin:0px;font-family:inherit;line-height:1.8;color:inherit;text-rendering:optimizelegibility;font-size:22px;">3、ScrollView page滑动</h3>
<p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">这是app store 应用的app封面预览功能</p>
<div class="image-package imagebubble" widget="ImageBubble" style="margin:0px auto 20px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/144142-cee9b6532795a034.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/144142-cee9b6532795a034.png?imageMogr2/auto-orient/strip%7CimageView2/2" class="imagebubble-image" style="height:auto;vertical-align:middle;border:0px;cursor:-webkit-zoom-in;-webkit-transition:all 0.25s ease-in-out;transition:all 0.25s ease-in-out;" /><br />
<div class="image-caption" style="min-width:20%;min-height:22px;display:inline-block;padding:10px;margin:0px auto;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#d9d9d9;font-size:13px;color:#999999;font-style:italic;line-height:1.7;">scrollview page</div>
</div>
<p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">上图的交互常常见于很多海报、封面展示的app，实现这个交互的方法有很多，但选择用scrollView来横向滑动来做是最简单的，让scrollview.pageEnabel = YES，就有了翻页的感觉，但这样scoreView的实际可滑动区域就只有一张照片那么宽，如果想让边侧留出的距离(蓝色框部分)响应滑动事件的话应该怎么办呢？这个时候又可以用到hit-test view的知识了，在scrollview的父view中把蓝色部分的事件都传递给scrollView就可以了，具体看下面代码：</p>
<pre class="hljs objectivec" style="padding:9.5px;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;color:#657b83;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:4px;border-bottom-left-radius:4px;margin-top:0px;margin-bottom:20px;line-height:20px;word-break:break-all;word-wrap:normal;background-color:#fdf6e3;border:1px solid rgba(0, 0, 0, 0.14902);overflow:auto;"><code class="objectivec" style="padding:0px;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;border-top-left-radius:3px;border-top-right-radius:3px;border-bottom-right-radius:3px;border-bottom-left-radius:3px;background-color:transparent;border:none;"><span class="hljs-comment" style="color:#93a1a1;">//in scrollView.superView .m</span> - (<span class="hljs-built_in" style="color:#268bd2;">UIView</span> *)hitTest:(<span class="hljs-built_in" style="color:#268bd2;">CGPoint</span>)point withEvent:(<span class="hljs-built_in" style="color:#268bd2;">UIEvent</span> *)event {

    <span class="hljs-built_in" style="color:#268bd2;">UIView</span> *hitTestView = [<span class="hljs-keyword" style="color:#859900;">super</span> hitTest:point withEvent:event];
    <span class="hljs-keyword" style="color:#859900;">if</span> (hitTestView) {
        hitTestView = <span class="hljs-keyword" style="color:#859900;">self</span><span class="hljs-variable" style="color:#b58900;">.scrollView</span>;
    }
    <span class="hljs-keyword" style="color:#859900;">return</span> hitTestView;
}</code></pre><h2 style="margin:0px;font-family:inherit;line-height:1.8;color:inherit;text-rendering:optimizelegibility;font-size:24px;">总结</h2>
<p style="margin-top:0px;margin-bottom:25px;text-align:justify;word-break:break-word;">事件响应链是UI层一个非常重要的概念，想做出非常棒的交互和动画，必须对其有一个深入的理解。我列举的只是我在开发中遇到的一些问题，如果有其他的对事件响应链的应用希望大家和我一起交流探讨。</p>
</div></body></html>