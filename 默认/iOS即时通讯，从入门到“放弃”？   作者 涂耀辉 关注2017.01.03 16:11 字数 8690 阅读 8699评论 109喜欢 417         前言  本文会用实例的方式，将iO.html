<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content=mNote Mac 2.5.11"/><meta name="created" content="2017-02-16T06:49:10Z"/><meta name="updated" content="2017-02-16T06:49:13Z"/><title>iOS即时通讯，从入门到“放弃”？   作者 涂耀辉 关注2017.01.03 16:11 字数 8690 阅读 8699评论 109喜欢 417         前言  本文会用实例的方式，将iO</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><h1 class="title" style="box-sizing:border-box;font-size:34px;margin:20px 0px 0px;font-family:-apple-system, 'SF UI Display', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;line-height:1.3;color:#333333;word-break:break-word;font-variant-ligatures:normal;orphans:2;widows:2;">iOS即时通讯，从入门到“放弃”？</h1>
<div class="author" style="box-sizing:border-box;margin:30px 0px 40px;color:#333333;font-family:-apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;font-size:17px;font-variant-ligatures:normal;orphans:2;widows:2;"><a class="avatar" href="http://www.jianshu.com/u/14431e509ae8" style="box-sizing:border-box;background-color:transparent;color:#333333;text-decoration:none;cursor:pointer;width:48px;height:48px;display:inline-block;vertical-align:middle;"><img src="http://upload.jianshu.io/users/upload_avatars/2702646/39580c57c281?imageMogr2/auto-orient/strip|imageView2/1/w/144/h/144" alt="144" style="box-sizing:border-box;border:1px solid #dddddd;vertical-align:middle;width:48px;height:48px;border-radius:50%;" /></a>&nbsp;<div class="info" style="box-sizing:border-box;vertical-align:middle;display:inline-block;margin-left:8px;"><span class="tag" style="box-sizing:border-box;padding:1px 2px;font-size:12px;color:#ea6f5a;border:1px solid #ea6f5a;border-radius:3px;">作者</span>&nbsp;<span class="name" style="box-sizing:border-box;margin-left:3px;margin-right:3px;font-size:16px;vertical-align:middle;"><a href="http://www.jianshu.com/u/14431e509ae8" style="box-sizing:border-box;background-color:transparent;color:#333333;text-decoration:none;cursor:pointer;">涂耀辉</a></span>&nbsp;<a class="btn btn-success follow" style="box-sizing:border-box;background-color:#42c02e;color:#ffffff;cursor:pointer;display:inline-block;margin-bottom:0px;text-align:center;vertical-align:middle;background-image:none;border:1px solid #42c02e;white-space:nowrap;padding:0px 7px 0px 5px;font-size:12px;line-height:normal;border-top-left-radius:40px;border-top-right-radius:40px;border-bottom-right-radius:40px;border-bottom-left-radius:40px;"><span style="box-sizing:border-box;margin-left:2px;">关注</span></a><div class="meta" style="box-sizing:border-box;margin-top:5px;font-size:12px;color:#969696;"><span class="publish-time" style="box-sizing:border-box;padding-right:5px;">2017.01.03 16:11</span>&nbsp;<span class="wordage" style="box-sizing:border-box;padding-right:5px;">字数 8690</span>&nbsp;<span class="views-count" style="box-sizing:border-box;padding-right:5px;">阅读 8699</span><span class="comments-count" style="box-sizing:border-box;padding-right:5px;">评论 109</span><span class="likes-count" style="box-sizing:border-box;padding-right:5px;">喜欢 417</span></div>
</div>
</div>
<div class="show-content" style="box-sizing:border-box;color:#2f2f2f;word-break:break-word;font-size:16px;line-height:1.7;font-family:-apple-system, 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-9345b2e50209bd68.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-9345b2e50209bd68.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
</div>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">前言</h6>
<ul style="box-sizing:border-box;margin-top:0px;margin-bottom:20px;padding:0px;word-break:break-word;margin-left:22px;"><li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;"><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;overflow:visible;"><span style="box-sizing:border-box;font-weight:700;">本文会用实例的方式，将iOS各种IM的方案都简单的实现一遍。并且提供一些选型、实现细节以及优化的建议。</span></p>
</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;"><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;overflow:visible;">注：文中的所有的代码示例，在github中都有demo：<br style="box-sizing:border-box;" />
<a href="https://github.com/tuyaohui/IM_iOS" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">iOS即时通讯，从入门到“放弃”？(demo)</a><br style="box-sizing:border-box;" />
可以打开项目先预览效果，对照着进行阅读。</p>
</li>
</ul>
<h4 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:20px;text-rendering:optimizelegibility;">言归正传，首先我们来总结一下我们去实现IM的方式</h4>
<h5 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:18px;text-rendering:optimizelegibility;">第一种方式，使用第三方IM服务</h5>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">对于短平快的公司，完全可以采用第三方SDK来实现。国内IM的第三方服务商有很多，类似云信、环信、融云、LeanCloud，当然还有其它的很多，这里就不一一举例了，感兴趣的小伙伴可以自行查阅下。</p>
<ul style="box-sizing:border-box;margin-top:0px;margin-bottom:20px;padding:0px;word-break:break-word;margin-left:22px;"><li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">第三方服务商IM底层协议基本上都是<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TCP</code>。他们的IM方案很成熟，有了它们，我们甚至不需要自己去搭建IM后台，什么都不需要去考虑。<br style="box-sizing:border-box;" />
如果你足够懒，甚至连UI都不需要自己做，这些第三方有各自一套IM的UI，拿来就可以直接用。真可谓3分钟集成...</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">但是缺点也很明显，定制化程度太高，很多东西我们不可控。<span style="box-sizing:border-box;font-weight:700;">当然还有一个最最重要的一点，就是太贵了...</span>作为真正社交为主打的APP，仅此一点，就足以让我们望而却步。当然，如果IM对于APP只是一个辅助功能，那么用第三方服务也无可厚非。</li>
</ul>
<h5 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:18px;text-rendering:optimizelegibility;">另外一种方式，我们自己去实现</h5>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">我们自己去实现也有很多选择：<br style="box-sizing:border-box;" />
1）首先面临的就是传输协议的选择，<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TCP</code>还是<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">UDP</code>？<br style="box-sizing:border-box;" />
2）其次是我们需要去选择使用哪种聊天协议：</p>
<ul style="box-sizing:border-box;margin-top:0px;margin-bottom:20px;padding:0px;word-break:break-word;margin-left:22px;"><li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">基于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Scoket</code>或者<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">WebScoket</code>或者其他的私有协议、</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;"><code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">MQTT</code></li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">还是广为人诟病的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">XMPP</code>?</li>
</ul>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">3）我们是自己去基于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">OS</code>底层<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Socket</code>进行封装还是在第三方框架的基础上进行封装？<br style="box-sizing:border-box;" />
4）传输数据的格式，我们是用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Json</code>、还是<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">XML</code>、还是谷歌推出的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">ProtocolBuffer</code>？<br style="box-sizing:border-box;" />
5）我们还有一些细节问题需要考虑，例如TCP的长连接如何保持，心跳机制，Qos机制，重连机制等等...当然，除此之外，我们还有一些安全问题需要考虑。</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">一、传输协议的选择</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">接下来我们可能需要自己考虑去实现IM，首先从传输层协议来说，我们有两种选择：<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TCP</code>&nbsp;or&nbsp;<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">UDP</code>？</p>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-2d6dc11cbf1ddabb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-2d6dc11cbf1ddabb.png?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
</div>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><br style="box-sizing:border-box;" />
这个问题已经被讨论过无数次了，对深层次的细节感兴趣的朋友可以看看这篇文章：</p>
<ul style="box-sizing:border-box;margin-top:0px;margin-bottom:20px;padding:0px;word-break:break-word;margin-left:22px;"><li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;"><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;overflow:visible;"><a href="http://www.52im.net/thread-33-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">移动端IM/推送系统的协议选型：UDP还是TCP？</a></p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;overflow:visible;">这里我们直接说结论吧：对于小公司或者技术不那么成熟的公司，IM一定要用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TCP</code>来实现，因为如果你要用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">UDP</code>的话，需要做的事太多。当然QQ就是用的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">UDP</code>协议，当然不仅仅是<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">UDP</code>，腾讯还用了自己的私有协议，来保证了传输的可靠性，杜绝了UDP下各种数据丢包，乱序等等一系列问题。<br style="box-sizing:border-box;" />
总之一句话，<span style="box-sizing:border-box;font-weight:700;">如果你觉得团队技术很成熟，那么你用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">UDP</code>也行，否则还是用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TCP</code>为好。</span></p>
</li>
</ul>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">二、我们来看看各种聊天协议</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">首先我们以实现方式来切入，基本上有以下四种实现方式：</p>
<ol style="box-sizing:border-box;margin-top:0px;margin-bottom:20px;word-break:break-word;padding:0px;margin-left:22px;"><li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">基于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Scoket</code>原生：代表框架&nbsp;<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">CocoaAsyncSocket</code>。</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">基于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">WebScoket</code>：代表框架&nbsp;<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">SocketRocket</code>。</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">基于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">MQTT</code>：代表框架&nbsp;<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">MQTTKit</code>。</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">基于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">XMPP</code>：代表框架&nbsp;<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">XMPPFramework</code>。</li>
</ol>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">当然，以上四种方式我们都可以不使用第三方框架，直接基于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">OS</code>底层<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Scoket</code>去实现我们的自定义封装。下面我会给出一个基于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Scoket</code>原生而不使用框架的例子，供大家参考一下。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">首先需要搞清楚的是，其中<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">MQTT</code>和<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">XMPP</code>为聊天协议，它们是最上层的协议，而<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">WebScoket</code>是传输通讯协议，它是基于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Socket</code>封装的一个协议。而通常我们所说的腾讯IM的私有协议，<span style="box-sizing:border-box;font-weight:700;">就是基于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">WebScoket</code>或者<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Scoket</code>原生进行封装的一个聊天协议。</span></p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">具体这3种聊天协议的对比优劣如下：</p>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-c225bb81f580718d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-c225bb81f580718d.png?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
<div class="image-caption" style="box-sizing:border-box;min-width:20%;max-width:80%;min-height:22px;display:inline-block;padding:10px;margin:0px auto;border-bottom:1px solid #d9d9d9;font-size:14px;color:#969696;line-height:1.7;">协议优劣对比.png</div>
</div>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">所以说到底，iOS要做一个真正的IM产品，一般都是基于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Scoket</code>或者<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">WebScoket</code>等，再之上加上一些私有协议来保证的。</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">1.我们先不使用任何框架，直接用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">OS</code>底层<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Socket</code>来实现一个简单的IM。</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">我们客户端的实现思路也是很简单，创建<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Socket</code>，和服务器的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Socket</code>对接上，然后开始传输数据就可以了。</p>
<ul style="box-sizing:border-box;margin-top:0px;margin-bottom:20px;padding:0px;word-break:break-word;margin-left:22px;"><li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;"><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;overflow:visible;">我们学过c/c++或者java这些语言，我们就知道，往往任何教程，最后一章都是讲<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Socket</code>编程，而<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Socket</code>是什么呢，简单的来说，就是我们使用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TCP/IP</code>&nbsp;或者<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">UDP/IP</code>协议的一组编程接口。如下图所示：</p>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:auto !important;margin-left:0px !important;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-5eaf55a2a5469d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-5eaf55a2a5469d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
</div>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;overflow:visible;">我们在应用层，使用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">socket</code>，轻易的实现了进程之间的通信（跨网络的）。想想，如果没有<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">socket</code>，我们要直面<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TCP/IP</code>协议，我们需要去写多少繁琐而又重复的代码。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;overflow:visible;">如果有对<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">socket</code>概念仍然有所困惑的，可以看看这篇文章：<br style="box-sizing:border-box;" />
<a href="http://blog.csdn.net/yeyuangen/article/details/6799575" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">从问题看本质，socket到底是什么？</a>。<br style="box-sizing:border-box;" />
但是这篇文章关于并发连接数的认识是错误的，正确的认识可以看看这篇文章:<br style="box-sizing:border-box;" />
<a href="http://www.52im.net/thread-561-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">单台服务器并发TCP连接数到底可以有多少</a></p>
</li>
</ul>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">我们接着可以开始着手去实现IM了，首先我们不基于任何框架，直接去调用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">OS</code>底层-基于C的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">BSD Socket</code>去实现，它提供了这样一组接口：</p>
<pre class="hljs arduino" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="arduino" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//socket 创建并初始化 socket，返回该 socket 的文件描述符，如果描述符为 -1 表示创建失败。</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> socket(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> addressFamily, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> type,<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> protocol)<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//关闭socket连接</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">close</span>(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> socketFileDescriptor)<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//将 socket 与特定主机地址与端口号绑定，成功绑定返回0，失败返回 -1。</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> bind(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> socketFileDescriptor,sockaddr *addressToBind,<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> addressStructLength)<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//接受客户端连接请求并将客户端的网络地址信息保存到 clientAddress 中。</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> accept(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> socketFileDescriptor,sockaddr *clientAddress, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> clientAddressStructLength)<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//客户端向特定网络地址的服务器发送连接请求，连接成功返回0，失败返回 -1。</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">connect</span>(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> socketFileDescriptor,sockaddr *serverAddress, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> serverAddressLength)<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//使用 DNS 查找特定主机名字对应的 IP 地址。如果找不到对应的 IP 地址则返回 NULL。</span> hostent* gethostbyname(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">char</span> *hostname)<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//通过 socket 发送数据，发送成功返回成功发送的字节数，否则返回 -1。</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> send(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> socketFileDescriptor, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">char</span> *<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">buffer</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> bufferLength, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> flags)<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//从 socket 中读取数据，读取成功返回成功读取的字节数，否则返回 -1。</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> receive(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> socketFileDescriptor,<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">char</span> *<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">buffer</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> bufferLength, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> flags)<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//通过UDP socket 发送数据到特定的网络地址，发送成功返回成功发送的字节数，否则返回 -1。</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> sendto(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> socketFileDescriptor,<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">char</span> *<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">buffer</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> bufferLength, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> flags, sockaddr *destinationAddress, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> destinationAddressLength)<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//从UDP socket 中读取数据，并保存发送者的网络地址信息，读取成功返回成功读取的字节数，否则返回 -1 。</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> recvfrom(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> socketFileDescriptor,<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">char</span> *<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">buffer</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> bufferLength, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> flags, sockaddr *fromAddress, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> *fromAddressLength)</code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">让我们可以对socket进行各种操作，首先我们来用它写个客户端。总结一下，简单的IM客户端需要做如下4件事：</p>
<ol style="box-sizing:border-box;margin-top:0px;margin-bottom:20px;word-break:break-word;padding:0px;margin-left:22px;"><li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">客户端调用 socket(...) 创建socket；</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">客户端调用 connect(...) 向服务器发起连接请求以建立连接；</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">客户端与服务器建立连接之后，就可以通过send(...)/receive(...)向客户端发送或从客户端接收数据；</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">客户端调用 close 关闭 socket；</li>
</ol>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">根据上面4条大纲，我们封装了一个名为<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TYHSocketManager</code>的单例，来对<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">socket</code>相关方法进行调用:</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TYHSocketManager.h</code></p>
<pre class="hljs objectivec" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="objectivec" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">&lt;Foundation/Foundation.h&gt;</span></span> <span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@interface</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">TYHSocketManager</span> : <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">NSObject</span></span> + (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">instancetype</span>)share;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)connect;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)disConnect;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)sendMsg:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)msg;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@end</span></code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TYHSocketManager.m</code></p>
<pre class="hljs objectivec" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="objectivec" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">"TYHSocketManager.h"</span></span> <span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">&lt;sys/types.h&gt;</span></span> <span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">&lt;sys/socket.h&gt;</span></span> <span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">&lt;netinet/in.h&gt;</span></span> <span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">&lt;arpa/inet.h&gt;</span></span> <span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@interface</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">TYHSocketManager</span>()</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">nonatomic</span>,<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">assign</span>)<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> clientScoket;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@end</span> <span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@implementation</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">TYHSocketManager</span></span> + (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">instancetype</span>)share
{
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span> <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">dispatch_once_t</span> onceToken;
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span> TYHSocketManager *instance = <span class="hljs-literal" style="box-sizing:border-box;">nil</span>;
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">dispatch_once</span>(&amp;onceToken, ^{
        instance = [[<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> alloc]init];
        [instance initScoket];
        [instance pullMsg];
    });
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">return</span> instance;
}

- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)initScoket
{
    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//每次连接前，先断开连接</span>     <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">if</span> (_clientScoket != <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">0</span>) {
        [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> disConnect];
        _clientScoket = <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">0</span>;
    }

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//创建客户端socket</span>     _clientScoket = CreateClinetSocket();

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//服务器Ip</span>     <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">const</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">char</span> * server_ip=<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">"127.0.0.1"</span>;
    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//服务器端口</span>     <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">short</span> server_port=<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">6969</span>;
    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//等于0说明连接失败</span>     <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">if</span> (ConnectionToServer(_clientScoket,server_ip, server_port)==<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">0</span>) {
        printf(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">"Connect to server error\n"</span>);
        <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">return</span> ;
    }
    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//走到这说明连接成功</span>     printf(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">"Connect to server ok\n"</span>);
}<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> CreateClinetSocket()
{
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> ClinetSocket = <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">0</span>;
    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//创建一个socket,返回值为Int。（注scoket其实就是Int类型）</span>     <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//第一个参数addressFamily IPv4(AF_INET) 或 IPv6(AF_INET6)。</span>     <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//第二个参数 type 表示 socket 的类型，通常是流stream(SOCK_STREAM) 或数据报文datagram(SOCK_DGRAM)</span>     <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//第三个参数 protocol 参数通常设置为0，以便让系统自动为选择我们合适的协议，对于 stream socket 来说会是 TCP 协议(IPPROTO_TCP)，而对于 datagram来说会是 UDP 协议(IPPROTO_UDP)。</span>     ClinetSocket = socket(AF_INET, SOCK_STREAM, <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">0</span>);
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">return</span> ClinetSocket;
}<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> ConnectionToServer(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> client_socket,<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">const</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">char</span> * server_ip,<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">unsigned</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">short</span> port)
{

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//生成一个sockaddr_in类型结构体</span>     <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">struct</span> sockaddr_in sAddr={<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">0</span>};
    sAddr.sin_len=<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">sizeof</span>(sAddr);
    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//设置IPv4</span>     sAddr.sin_family=AF_INET;

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//inet_aton是一个改进的方法来将一个字符串IP地址转换为一个32位的网络序列IP地址</span>     <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//如果这个函数成功，函数的返回值非零，如果输入地址不正确则会返回零。</span>     inet_aton(server_ip, &amp;sAddr.sin_addr);

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//htons是将整型变量从主机字节顺序转变成网络字节顺序，赋值端口号</span>     sAddr.sin_port=htons(port);

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//用scoket和服务端地址，发起连接。</span>     <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//客户端向特定网络地址的服务器发送连接请求，连接成功返回0，失败返回 -1。</span>     <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//注意：该接口调用会阻塞当前线程，直到服务器返回。</span>     <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">if</span> (connect(client_socket, (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">struct</span> sockaddr *)&amp;sAddr, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">sizeof</span>(sAddr))==<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">0</span>) {
        <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">return</span> client_socket;
    }
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">return</span> <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">0</span>;
}<span class="hljs-meta" style="box-sizing:border-box;">#pragma mark - 新线程来接收消息</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)pullMsg
{
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSThread</span> *thread = [[<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSThread</span> alloc]initWithTarget:<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> selector:<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@selector</span>(recieveAction) object:<span class="hljs-literal" style="box-sizing:border-box;">nil</span>];
    [thread start];
}<span class="hljs-meta" style="box-sizing:border-box;">#pragma mark - 对外逻辑</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)connect
{
    [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> initScoket];
}
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)disConnect
{
    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//关闭连接</span>     close(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span>.clientScoket);
}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//发送消息</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)sendMsg:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)msg
{

    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">const</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">char</span> *send_Message = [msg UTF8String];
    send(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span>.clientScoket,send_Message,strlen(send_Message)+<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">1</span>,<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">0</span>);

}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//收取服务端发送的消息</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)recieveAction{
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">while</span> (<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">1</span>) {
        <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">char</span> recv_Message[<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">1024</span>] = {<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">0</span>};
        recv(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span>.clientScoket, recv_Message, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">sizeof</span>(recv_Message), <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">0</span>);
        printf(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">"%s\n"</span>,recv_Message);
    }
}</code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">如上所示:</p>
<ul style="box-sizing:border-box;margin-top:0px;margin-bottom:20px;padding:0px;word-break:break-word;margin-left:22px;"><li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">我们调用了<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">initScoket</code>方法，利用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">CreateClinetSocket</code>方法了一个<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">scoket</code>，就是就是调用了socket函数：<pre class="hljs ebnf" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="ebnf" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-attribute" style="box-sizing:border-box;color:#b58900;">ClinetSocket</span> = socket(AF_INET, SOCK_STREAM, 0);</code></pre></li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;"><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;overflow:visible;">然后调用了<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">ConnectionToServer</code>函数与服务器连接，IP地址为<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">127.0.0.1</code>也就是本机<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">localhost</code>和端口<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">6969</code>相连。在该函数中，我们绑定了一个<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">sockaddr_in</code>类型的结构体，该结构体内容如下：</p>
<pre class="hljs abnf" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="abnf" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;">struct sockaddr_in {
  __uint8_t    sin_len<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">;</span>   sa_family_t    sin_family<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">;</span>   in_port_t    sin_port<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">;</span>   struct    in_addr sin_addr<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">;</span>   char        sin_zero[<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">8</span>]<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">;</span> }<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">;</span></code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;overflow:visible;">里面包含了一些，我们需要连接的服务端的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">scoket</code>的一些基本参数，具体赋值细节可以见注释。</p>
</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;"><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;overflow:visible;">连接成功之后，我们就可以调用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">send</code>函数和<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">recv</code>函数进行消息收发了，在这里，我新开辟了一个常驻线程，在这个线程中一个死循环里去不停的调用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">recv</code>函数，这样服务端有消息发送过来，第一时间便能被接收到。</p>
</li>
</ul>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">就这样客户端便简单的可以用了，接着我们来看看服务端的实现。</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">一样，我们首先对服务端需要做的工作简单的总结下：</h6>
<ol style="box-sizing:border-box;margin-top:0px;margin-bottom:20px;word-break:break-word;padding:0px;margin-left:22px;"><li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">服务器调用 socket(...) 创建socket；</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">服务器调用 listen(...) 设置缓冲区；</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">服务器通过 accept(...)接受客户端请求建立连接；</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">服务器与客户端建立连接之后，就可以通过 send(...)/receive(...)向客户端发送或从客户端接收数据；</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">服务器调用 close 关闭 socket；</li>
</ol>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">接着我们就可以具体去实现了</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">OS</code>底层的函数是支持我们去实现服务端的，但是我们一般不会用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">iOS</code>去这么做（试问真正的应用场景，有谁用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">iOS</code>做<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">scoket</code>服务器么...），如果还是想用这些函数去实现服务端，可以参考下这篇文章：&nbsp;<a href="http://blog.csdn.net/kesalin/article/details/8798039" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">深入浅出Cocoa-iOS网络编程之Socket</a>。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">在这里我用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">node.js</code>去搭了一个简单的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">scoket</code>服务器。源码如下：</p>
<pre class="hljs javascript" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="javascript" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">var</span> net = <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">require</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'net'</span>);  <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">var</span> HOST = <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'127.0.0.1'</span>;  <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">var</span> PORT = <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">6969</span>;  <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// 创建一个TCP服务器实例，调用listen函数开始监听指定端口  </span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// 传入net.createServer()的回调函数将作为”connection“事件的处理函数  </span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// 在每一个“connection”事件中，该回调函数接收到的socket对象是唯一的  </span> net.createServer(<span class="hljs-function" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">function</span>(<span class="hljs-params" style="box-sizing:border-box;">sock</span>) </span>{  

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// 我们获得一个连接 - 该连接自动关联一个socket对象  </span>     <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">console</span>.log(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'CONNECTED: '</span> +  
        sock.remoteAddress + <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">':'</span> + sock.remotePort);  
        sock.write(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'服务端发出：连接成功'</span>);  

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// 为这个socket实例添加一个"data"事件处理函数  </span>     sock.on(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'data'</span>, <span class="hljs-function" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">function</span>(<span class="hljs-params" style="box-sizing:border-box;">data</span>) </span>{  
        <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">console</span>.log(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'DATA '</span> + sock.remoteAddress + <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">': '</span> + data);  
        <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// 回发该数据，客户端将收到来自服务端的数据  </span>         sock.write(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'You said "'</span> + data + <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'"'</span>);  
    });  
    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// 为这个socket实例添加一个"close"事件处理函数  </span>     sock.on(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'close'</span>, <span class="hljs-function" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">function</span>(<span class="hljs-params" style="box-sizing:border-box;">data</span>) </span>{  
        <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">console</span>.log(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'CLOSED: '</span> +  
        sock.remoteAddress + <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">' '</span> + sock.remotePort);  
    });  

}).listen(PORT, HOST);  <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">console</span>.log(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'Server listening on '</span> + HOST +<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">':'</span>+ PORT);</code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">看到这不懂<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">node.js</code>的朋友也不用着急，在这里你可以使用任意语言c/c++/java/oc等等去实现后台，这里<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">node.js</code>仅仅是楼主的一个选择，为了让我们来验证之前写的客户端<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">scoket</code>的效果。如果你不懂<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">node.js</code>也没关系，你只需要把上述楼主写的相关代码复制粘贴，如果你本机有node的解释器，那么直接在终端进入该源代码文件目录中输入：</p>
<pre class="hljs crmsh" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="crmsh" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">node</span> <span class="hljs-title" style="box-sizing:border-box;color:#268bd2;">fileName</span></code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">即可运行该脚本（fileName为保存源代码的文件名）。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">我们来看看运行效果：</p>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-dd635641474fa29e.gif?imageMogr2/auto-orient/strip" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-dd635641474fa29e.gif?imageMogr2/auto-orient/strip" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
<div class="image-caption" style="box-sizing:border-box;min-width:20%;max-width:80%;min-height:22px;display:inline-block;padding:10px;margin:0px auto;border-bottom:1px solid #d9d9d9;font-size:14px;color:#969696;line-height:1.7;">handle2.gif</div>
</div>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><br style="box-sizing:border-box;" />
服务器运行起来了，并且监听着6969端口。<br style="box-sizing:border-box;" />
接着我们用之前写的iOS端的例子。客户端打印显示连接成功，而我们运行的服务器也打印了连接成功。接着我们发了一条消息，服务端成功的接收到了消息后，把该消息再发送回客户端，绕了一圈客户端又收到了这条消息。至此我们用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">OS</code>底层<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">scoket</code>实现了简单的IM。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">大家看到这是不是觉得太过简单了？<br style="box-sizing:border-box;" />
当然简单，我们仅仅是实现了Scoket的连接，信息的发送与接收，除此之外我们什么都没有做，现实中，我们需要做的处理远不止于此，我们先接着往下看。接下来，我们就一起看看第三方框架是如何实现IM的。</p>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-bddc7341d9eda6ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-bddc7341d9eda6ae.png?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
<div class="image-caption" style="box-sizing:border-box;min-width:20%;max-width:80%;min-height:22px;display:inline-block;padding:10px;margin:0px auto;border-bottom:1px solid #d9d9d9;font-size:14px;color:#969696;line-height:1.7;">分割图.png</div>
</div>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">2.我们接着来看看基于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Socket</code>原生的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">CocoaAsyncSocket</code>:</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">这个框架实现了两种传输协议<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TCP</code>和<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">UDP</code>，分别对应<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">GCDAsyncSocket</code>类和<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">GCDAsyncUdpSocket</code>，这里我们重点讲<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">GCDAsyncSocket</code>。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">这里Socket服务器延续上一个例子，因为同样是基于原生Scoket的框架，所以之前的Node.js的服务端，该例仍然试用。这里我们就只需要去封装客户端的实例，我们还是创建一个<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TYHSocketManager</code>单例。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TYHSocketManager.h</code></p>
<pre class="hljs objectivec" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="objectivec" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">&lt;Foundation/Foundation.h&gt;</span></span> <span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@interface</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">TYHSocketManager</span> : <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">NSObject</span></span> + (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">instancetype</span>)share;

- (<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">BOOL</span>)connect;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)disConnect;

- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)sendMsg:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)msg;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)pullTheMsg;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@end</span></code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TYHSocketManager.m</code></p>
<pre class="hljs objectivec" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="objectivec" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">"TYHSocketManager.h"</span></span> <span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">"GCDAsyncSocket.h"</span> // for TCP</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span>  <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> * Khost = <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"127.0.0.1"</span>;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">const</span> uint16_t Kport = <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">6969</span>;<span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@interface</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">TYHSocketManager</span>()&lt;<span class="hljs-title" style="box-sizing:border-box;color:#b58900;">GCDAsyncSocketDelegate</span>&gt;</span> {
    GCDAsyncSocket *gcdSocket;
}<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@end</span> <span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@implementation</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">TYHSocketManager</span></span> + (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">instancetype</span>)share
{
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span> <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">dispatch_once_t</span> onceToken;
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span> TYHSocketManager *instance = <span class="hljs-literal" style="box-sizing:border-box;">nil</span>;
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">dispatch_once</span>(&amp;onceToken, ^{
        instance = [[<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> alloc]init];
        [instance initSocket];
    });
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">return</span> instance;
}

- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)initSocket
{
    gcdSocket = [[GCDAsyncSocket alloc] initWithDelegate:<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> delegateQueue:dispatch_get_main_queue()];

}<span class="hljs-meta" style="box-sizing:border-box;">#pragma mark - 对外的一些接口</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//建立连接</span> - (<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">BOOL</span>)connect
{
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">return</span>  [gcdSocket connectToHost:Khost onPort:Kport error:<span class="hljs-literal" style="box-sizing:border-box;">nil</span>];
}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//断开连接</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)disConnect
{
    [gcdSocket disconnect];
}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//发送消息</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)sendMsg:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)msg

{
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSData</span> *data  = [msg dataUsingEncoding:<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSUTF8StringEncoding</span>];
    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//第二个参数，请求超时时间</span>     [gcdSocket writeData:data withTimeout:<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">-1</span> tag:<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">110</span>];

}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//监听最新的消息</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)pullTheMsg
{
    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//监听读数据的代理  -1永远监听，不超时，但是只收一次消息，</span>     <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//所以每次接受到消息还得调用一次</span>     [gcdSocket readDataWithTimeout:<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">-1</span> tag:<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">110</span>];

}<span class="hljs-meta" style="box-sizing:border-box;">#pragma mark - GCDAsyncSocketDelegate</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//连接成功调用</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)socket:(GCDAsyncSocket *)sock didConnectToHost:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)host port:(uint16_t)port
{
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"连接成功,host:%@,port:%d"</span>,host,port);

    [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> pullTheMsg];

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//心跳写在这...</span> }<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//断开连接的时候调用</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">nullable</span> <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSError</span> *)err
{
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"断开连接,host:%@,port:%d"</span>,sock.localHost,sock.localPort);

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//断线重连写在这...</span> }<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//写成功的回调</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)socket:(GCDAsyncSocket*)sock didWriteDataWithTag:(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">long</span>)tag
{<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//    NSLog(@"写的回调,tag:%ld",tag);</span> }<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//收到消息的回调</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)socket:(GCDAsyncSocket *)sock didReadData:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSData</span> *)data withTag:(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">long</span>)tag
{

    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *msg = [[<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> alloc]initWithData:data encoding:<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSUTF8StringEncoding</span>];
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"收到消息：%@"</span>,msg);

    [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> pullTheMsg];
}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//分段去获取消息的回调</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//- (void)socket:(GCDAsyncSocket *)sock didReadPartialDataOfLength:(NSUInteger)partialLength tag:(long)tag</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//{</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//    </span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//    NSLog(@"读的回调,length:%ld,tag:%ld",partialLength,tag);</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//}</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//为上一次设置的读取数据代理续时 (如果设置超时为-1，则永远不会调用到)</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//-(NSTimeInterval)socket:(GCDAsyncSocket *)sock shouldTimeoutReadWithTag:(long)tag elapsed:(NSTimeInterval)elapsed bytesDone:(NSUInteger)length</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//{</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//    NSLog(@"来延时，tag:%ld,elapsed:%f,length:%ld",tag,elapsed,length);</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//    return 10;</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//}</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@end</span></code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">这个框架使用起来也十分简单，它基于Scoket往上进行了一层封装，提供了OC的接口给我们使用。至于使用方法，大家看看注释应该就能明白，这里唯一需要说的一点就是这个方法：</p>
<pre class="hljs groovy" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="groovy" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;">[gcdSocket <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">readDataWithTimeout:</span><span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">-1</span> <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">tag:</span><span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">110</span>];</code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">这个方法的作用就是去读取当前消息队列中的未读消息。<span style="box-sizing:border-box;font-weight:700;">记住，这里不调用这个方法，消息回调的代理是永远不会被触发的。</span>而且必须是tag相同，如果tag不同，这个收到消息的代理也不会被处罚。<br style="box-sizing:border-box;" />
我们调用一次这个方法，只能触发一次读取消息的代理，如果我们调用的时候没有未读消息，它就会等在那，直到消息来了被触发。一旦被触发一次代理后，我们必须再次调用这个方法，否则，之后的消息到了仍旧无法触发我们读取消息的代理。就像我们在例子中使用的那样，在每次读取到消息之后我们都去调用:</p>
<pre class="hljs groovy" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="groovy" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//收到消息的回调</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">socket:</span>(GCDAsyncSocket *)sock <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">didReadData:</span>(NSData *)data <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">withTag:</span>(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">long</span>)tag
{
    NSString *msg = [[NSString alloc]<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">initWithData:</span>data <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">encoding:</span>NSUTF8StringEncoding];
    NSLog(@<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">"收到消息：%@"</span>,msg);
    [self pullTheMsg];
}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//监听最新的消息</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)pullTheMsg
{
    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//监听读数据的代理，只能监听10秒，10秒过后调用代理方法  -1永远监听，不超时，但是只收一次消息，</span>     <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//所以每次接受到消息还得调用一次</span>     [gcdSocket <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">readDataWithTimeout:</span><span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">-1</span> <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">tag:</span><span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">110</span>];

}</code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">除此之外，我们还需要说的是这个超时<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">timeout</code><br style="box-sizing:border-box;" />
这里如果设置10秒，那么就只能监听10秒，10秒过后调用是否续时的代理方法:</p>
<pre class="hljs erlang" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="erlang" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;">-<span class="hljs-params" style="box-sizing:border-box;">(NSTimeInterval)</span>socket:<span class="hljs-params" style="box-sizing:border-box;">(GCDAsyncSocket *)</span>sock shouldTimeoutReadWithTag:<span class="hljs-params" style="box-sizing:border-box;">(long)</span>tag elapsed:<span class="hljs-params" style="box-sizing:border-box;">(NSTimeInterval)</span>elapsed bytesDone:<span class="hljs-params" style="box-sizing:border-box;">(NSUInteger)</span>length</code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">如果我们选择不续时，那么10秒到了还没收到消息，那么<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Scoket</code>会自动断开连接。看到这里有些小伙伴要吐槽了，怎么一个方法设计的这么麻烦，当然这里这么设计是有它的应用场景的，我们后面再来细讲。</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">我们同样来运行看看效果：</h6>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-d92af23f6589b863.gif?imageMogr2/auto-orient/strip" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-d92af23f6589b863.gif?imageMogr2/auto-orient/strip" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
<div class="image-caption" style="box-sizing:border-box;min-width:20%;max-width:80%;min-height:22px;display:inline-block;padding:10px;margin:0px auto;border-bottom:1px solid #d9d9d9;font-size:14px;color:#969696;line-height:1.7;">handle3.gif</div>
</div>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">至此我们也用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">CocoaAsyncSocket</code>这个框架实现了一个简单的IM。</p>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-f69cdb3f5cfd2611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-f69cdb3f5cfd2611.png?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
<div class="image-caption" style="box-sizing:border-box;min-width:20%;max-width:80%;min-height:22px;display:inline-block;padding:10px;margin:0px auto;border-bottom:1px solid #d9d9d9;font-size:14px;color:#969696;line-height:1.7;">分割图.png</div>
</div>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">3.接着我们继续来看看基于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">webScoket</code>的IM：</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">这个例子我们会把心跳，断线重连，以及PingPong机制进行简单的封装，所以我们先来谈谈这三个概念：</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">首先我们来谈谈什么是心跳</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">简单的来说，<span style="box-sizing:border-box;font-weight:700;">心跳就是用来检测TCP连接的双方是否可用。</span>那又会有人要问了，TCP不是本身就自带一个<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">KeepAlive</code>机制吗？<br style="box-sizing:border-box;" />
<span style="box-sizing:border-box;font-weight:700;">这里我们需要说明的是TCP的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">KeepAlive</code>机制只能保证连接的存在，但是并不能保证客户端以及服务端的可用性.</span>比如会有以下一种情况：</p>
<blockquote style="box-sizing:border-box;padding:20px;margin:0px 0px 25px;border-left-width:6px;border-left-style:solid;border-left-color:#b4b4b4;background-color:#f7f7f7;word-break:break-word;line-height:30px;"><p style="box-sizing:border-box;margin-top:0px;margin-bottom:0px;word-break:break-word;line-height:1.7;">某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针则仍旧能够确定连接状态，这就是典型的连接活着但业务提供方已死的状态。</p>
</blockquote>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">这个时候心跳机制就起到作用了：</p>
<ul style="box-sizing:border-box;margin-top:0px;margin-bottom:20px;padding:0px;word-break:break-word;margin-left:22px;"><li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">我们客户端发起心跳Ping（一般都是客户端），假如设置在10秒后如果没有收到回调，那么说明服务器或者客户端某一方出现问题，这时候我们需要主动断开连接。</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">服务端也是一样，会维护一个socket的心跳间隔，当约定时间内，没有收到客户端发来的心跳，我们会知道该连接已经失效，然后主动断开连接。</li>
</ul>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">参考文章：<a href="http://www.52im.net/thread-281-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">为什么说基于TCP的移动端IM仍然需要心跳保活？</a></p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">其实做过IM的小伙伴们都知道，我们真正需要心跳机制的原因其实主要是在于国内运营商<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">NAT</code>超时。</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">那么究竟什么是<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">NAT</code>超时呢?</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">原来这是因为IPV4引起的，我们上网很可能会处在一个NAT设备（无线路由器之类）之后。<br style="box-sizing:border-box;" />
NAT设备会在IP封包通过设备时修改源/目的IP地址. 对于家用路由器来说, 使用的是网络地址端口转换(NAPT), 它不仅改IP, 还修改TCP和UDP协议的端口号, 这样就能让内网中的设备共用同一个外网IP. 举个例子, NAPT维护一个类似下表的NAT表：<br style="box-sizing:border-box;" />
</p>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-cefd86afd8b99939.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-cefd86afd8b99939.png?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
<div class="image-caption" style="box-sizing:border-box;min-width:20%;max-width:80%;min-height:22px;display:inline-block;padding:10px;margin:0px auto;border-bottom:1px solid #d9d9d9;font-size:14px;color:#969696;line-height:1.7;">NAT映射</div>
</div>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><br style="box-sizing:border-box;" />
NAT设备会根据NAT表对出去和进来的数据做修改, 比如将<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">192.168.0.3:8888</code>发出去的封包改成<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">120.132.92.21:9202</code>, 外部就认为他们是在和<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">120.132.92.21:9202</code>通信. 同时NAT设备会将<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">120.132.92.21:9202</code>收到的封包的IP和端口改成<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">192.168.0.3:8888</code>, 再发给内网的主机, 这样内部和外部就能双向通信了, 但如果其中<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">192.168.0.3:8888</code>&nbsp;==&nbsp;<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">120.132.92.21:9202</code>这一映射因为某些原因被NAT设备淘汰了, 那么外部设备就无法直接与<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">192.168.0.3:8888</code>通信了。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">我们的设备经常是处在NAT设备的后面, 比如在大学里的校园网, 查一下自己分配到的IP, 其实是内网IP, 表明我们在NAT设备后面, 如果我们在寝室再接个路由器, 那么我们发出的数据包会多经过一次NAT.</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">国内移动无线网络运营商在链路上一段时间内没有数据通讯后, 会淘汰NAT表中的对应项, 造成链路中断。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><span style="box-sizing:border-box;font-weight:700;">而国内的运营商一般NAT超时的时间为5分钟，所以通常我们心跳设置的时间间隔为3-5分钟。</span></p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">接着我们来讲讲PingPong机制:</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">很多小伙伴可能又会感觉到疑惑了，那么我们在这心跳间隔的3-5分钟如果连接假在线（例如在地铁电梯这种环境下）。那么我们岂不是无法保证消息的即时性么？这显然是我们无法接受的，所以业内的解决方案是采用双向的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">PingPong</code>机制。<br style="box-sizing:border-box;" />
</p>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-6e51be4cf4ba7b11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-6e51be4cf4ba7b11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
</div>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">当服务端发出一个<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Ping</code>，客户端没有在约定的时间内返回响应的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">ack</code>，则认为客户端已经不在线，这时我们<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Server</code>端会主动断开<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Scoket</code>连接，并且改由<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">APNS</code>推送的方式发送消息。<br style="box-sizing:border-box;" />
同样的是，当客户端去发送一个消息，因为我们迟迟无法收到服务端的响应ack包，则表明客户端或者服务端已不在线，我们也会显示消息发送失败，并且断开<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Scoket</code>连接。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">还记得我们之前<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">CocoaSyncSockt</code>的例子所讲的获取消息超时就断开吗？其实它就是一个<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">PingPong</code>机制的客户端实现。我们每次可以在发送消息成功后，调用这个超时读取的方法，如果一段时间没收到服务器的响应，那么说明连接不可用，则断开<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Scoket</code>连接</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">最后就是重连机制:</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">理论上，我们自己主动去断开的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Scoket</code>连接（例如退出账号，APP退出到后台等等），不需要重连。其他的连接断开，我们都需要进行断线重连。<br style="box-sizing:border-box;" />
一般解决方案是尝试重连几次，如果仍旧无法重连成功，那么不再进行重连。<br style="box-sizing:border-box;" />
接下来的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">WebScoket</code>的例子，我会封装一个重连时间指数级增长的一个重连方式，可以作为一个参考。</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">言归正传，我们看完上述三个概念之后，我们来讲一个<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">WebScoket</code>最具代表性的一个第三方框架<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">SocketRocket</code>。</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">我们首先来看看它对外封装的一些方法：</p>
<pre class="hljs objectivec" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="objectivec" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@interface</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">SRWebSocket</span> : <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">NSObject</span> &lt;<span class="hljs-title" style="box-sizing:border-box;color:#b58900;">NSStreamDelegate</span>&gt;</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">nonatomic</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">weak</span>) <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">id</span> &lt;SRWebSocketDelegate&gt; delegate;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">nonatomic</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">readonly</span>) SRReadyState readyState;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">nonatomic</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">readonly</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">retain</span>) <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSURL</span> *url;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">nonatomic</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">readonly</span>) <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">CFHTTPMessageRef</span> receivedHTTPHeaders;<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// Optional array of cookies (NSHTTPCookie objects) to apply to the connections</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">nonatomic</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">readwrite</span>) <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSArray</span> * requestCookies;<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// This returns the negotiated protocol.</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// It will be nil until after the handshake completes.</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">nonatomic</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">readonly</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">copy</span>) <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *protocol;<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// Protocols should be an array of strings that turn into Sec-WebSocket-Protocol.</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">id</span>)initWithURLRequest:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSURLRequest</span> *)request protocols:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSArray</span> *)protocols allowsUntrustedSSLCertificates:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">BOOL</span>)allowsUntrustedSSLCertificates;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">id</span>)initWithURLRequest:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSURLRequest</span> *)request protocols:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSArray</span> *)protocols;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">id</span>)initWithURLRequest:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSURLRequest</span> *)request;<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// Some helper constructors.</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">id</span>)initWithURL:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSURL</span> *)url protocols:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSArray</span> *)protocols allowsUntrustedSSLCertificates:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">BOOL</span>)allowsUntrustedSSLCertificates;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">id</span>)initWithURL:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSURL</span> *)url protocols:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSArray</span> *)protocols;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">id</span>)initWithURL:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSURL</span> *)url;<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// Delegate queue will be dispatch_main_queue by default.</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// You cannot set both OperationQueue and dispatch_queue.</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)setDelegateOperationQueue:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSOperationQueue</span>*) queue;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)setDelegateDispatchQueue:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">dispatch_queue_t</span>) queue;<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// By default, it will schedule itself on +[NSRunLoop SR_networkRunLoop] using defaultModes.</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)scheduleInRunLoop:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSRunLoop</span> *)aRunLoop forMode:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)mode;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)unscheduleFromRunLoop:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSRunLoop</span> *)aRunLoop forMode:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)mode;<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// SRWebSockets are intended for one-time-use only.  Open should be called once and only once.</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)open;

- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)close;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)closeWithCode:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSInteger</span>)code reason:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)reason;<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// Send a UTF8 String or Data.</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)send:(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">id</span>)data;<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// Send Data (can be nil) in a ping message.</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)sendPing:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSData</span> *)data;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@end</span> <span class="hljs-meta" style="box-sizing:border-box;">#pragma mark - SRWebSocketDelegate</span> <span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@protocol</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">SRWebSocketDelegate</span> &lt;<span class="hljs-title" style="box-sizing:border-box;color:#b58900;">NSObject</span>&gt;</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// message will either be an NSString if the server is using text</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// or NSData if the server is using binary.</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">id</span>)message;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@optional</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)webSocketDidOpen:(SRWebSocket *)webSocket;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)webSocket:(SRWebSocket *)webSocket didFailWithError:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSError</span> *)error;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)webSocket:(SRWebSocket *)webSocket didCloseWithCode:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSInteger</span>)code reason:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)reason wasClean:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">BOOL</span>)wasClean;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)webSocket:(SRWebSocket *)webSocket didReceivePong:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSData</span> *)pongPayload;<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// Return YES to convert messages sent as Text to an NSString. Return NO to skip NSData -&gt; NSString conversion for Text messages. Defaults to YES.</span> - (<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">BOOL</span>)webSocketShouldConvertTextFrameToString:(SRWebSocket *)webSocket;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@end</span></code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">方法也很简单，分为两个部分：</p>
<ul style="box-sizing:border-box;margin-top:0px;margin-bottom:20px;padding:0px;word-break:break-word;margin-left:22px;"><li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">一部分为<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">SRWebSocket</code>的初始化，以及连接，关闭连接，发送消息等方法。</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">另一部分为<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">SRWebSocketDelegate</code>，其中包括一些回调：<br style="box-sizing:border-box;" />
收到消息的回调，连接失败的回调，关闭连接的回调，收到pong的回调，是否需要把data消息转换成string的代理方法。</li>
</ul>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">接着我们还是举个例子来实现以下，首先来封装一个<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TYHSocketManager</code>单例：</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TYHSocketManager.h</code></p>
<pre class="hljs objectivec" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="objectivec" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">&lt;Foundation/Foundation.h&gt;</span></span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">typedef</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">enum</span> : <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSUInteger</span> {
    disConnectByUser ,
    disConnectByServer,
} DisConnectType;<span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@interface</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">TYHSocketManager</span> : <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">NSObject</span></span> + (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">instancetype</span>)share;

- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)connect;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)disConnect;

- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)sendMsg:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)msg;

- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)ping;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@end</span></code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">TYHSocketManager.m</code></p>
<pre class="hljs objectivec" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="objectivec" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">"TYHSocketManager.h"</span></span> <span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">"SocketRocket.h"</span></span> <span class="hljs-meta" style="box-sizing:border-box;">#define dispatch_main_async_safe(block)\</span>     <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">if</span> ([<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSThread</span> isMainThread]) {\
        block();\
    } <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">else</span> {\
        <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">dispatch_async</span>(dispatch_get_main_queue(), block);\
    }<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span>  <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> * Khost = <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"127.0.0.1"</span>;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">const</span> uint16_t Kport = <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">6969</span>;<span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@interface</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">TYHSocketManager</span>()&lt;<span class="hljs-title" style="box-sizing:border-box;color:#b58900;">SRWebSocketDelegate</span>&gt;</span> {
    SRWebSocket *webSocket;
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSTimer</span> *heartBeat;
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSTimeInterval</span> reConnectTime;

}<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@end</span> <span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@implementation</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">TYHSocketManager</span></span> + (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">instancetype</span>)share
{
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span> <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">dispatch_once_t</span> onceToken;
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span> TYHSocketManager *instance = <span class="hljs-literal" style="box-sizing:border-box;">nil</span>;
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">dispatch_once</span>(&amp;onceToken, ^{
        instance = [[<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> alloc]init];
        [instance initSocket];
    });
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">return</span> instance;
}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//初始化连接</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)initSocket
{
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">if</span> (webSocket) {
        <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">return</span>;
    }


    webSocket = [[SRWebSocket alloc]initWithURL:[<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSURL</span> URLWithString:[<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> stringWithFormat:<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"ws://%@:%d"</span>, Khost, Kport]]];

    webSocket.delegate = <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span>;

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//设置代理线程queue</span>     <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSOperationQueue</span> *queue = [[<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSOperationQueue</span> alloc]init];
    queue.maxConcurrentOperationCount = <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">1</span>;

    [webSocket setDelegateOperationQueue:queue];

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//连接</span>     [webSocket open];


}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//初始化心跳</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)initHeartBeat
{

    dispatch_main_async_safe(^{

        [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> destoryHeartBeat];

        __<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">weak</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">typeof</span>(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span>) weakSelf = <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span>;
        <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//心跳设置为3分钟，NAT超时一般为5分钟</span>         heartBeat = [<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">3</span>*<span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">60</span> repeats:<span class="hljs-literal" style="box-sizing:border-box;">YES</span> block:^(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSTimer</span> * _Nonnull timer) {
            <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"heart"</span>);
            <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//和服务端约定好发送什么作为心跳标识，尽可能的减小心跳包大小</span>             [weakSelf sendMsg:<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"heart"</span>];
        }];
        [[<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSRunLoop</span> currentRunLoop]addTimer:heartBeat forMode:<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSRunLoopCommonModes</span>];
    })

}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//取消心跳</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)destoryHeartBeat
{
    dispatch_main_async_safe(^{
        <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">if</span> (heartBeat) {
            [heartBeat invalidate];
            heartBeat = <span class="hljs-literal" style="box-sizing:border-box;">nil</span>;
        }
    })

}<span class="hljs-meta" style="box-sizing:border-box;">#pragma mark - 对外的一些接口</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//建立连接</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)connect
{
    [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> initSocket];

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//每次正常连接的时候清零重连时间</span>     reConnectTime = <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">0</span>;
}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//断开连接</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)disConnect
{

    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">if</span> (webSocket) {
        [webSocket close];
        webSocket = <span class="hljs-literal" style="box-sizing:border-box;">nil</span>;
    }
}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//发送消息</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)sendMsg:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)msg
{
    [webSocket send:msg];

}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//重连机制</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)reConnect
{
    [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> disConnect];

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//超过一分钟就不再重连 所以只会重连5次 2^5 = 64</span>     <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">if</span> (reConnectTime &gt; <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">64</span>) {
        <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">return</span>;
    }

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(reConnectTime * <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^{
        webSocket = <span class="hljs-literal" style="box-sizing:border-box;">nil</span>;
        [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> initSocket];
    });


    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//重连时间2的指数级增长</span>     <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">if</span> (reConnectTime == <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">0</span>) {
        reConnectTime = <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">2</span>;
    }<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">else</span>{
        reConnectTime *= <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">2</span>;
    }

}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//pingPong</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)ping{

    [webSocket sendPing:<span class="hljs-literal" style="box-sizing:border-box;">nil</span>];
}<span class="hljs-meta" style="box-sizing:border-box;">#pragma mark - SRWebSocketDelegate</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">id</span>)message
{
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"服务器返回收到消息:%@"</span>,message);
}


- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)webSocketDidOpen:(SRWebSocket *)webSocket
{
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"连接成功"</span>);

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//连接成功了开始发送心跳</span>     [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> initHeartBeat];
}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//open失败的时候调用</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)webSocket:(SRWebSocket *)webSocket didFailWithError:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSError</span> *)error
{
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"连接失败.....\n%@"</span>,error);

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//失败了就去重连</span>     [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> reConnect];
}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//网络连接中断被调用</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)webSocket:(SRWebSocket *)webSocket didCloseWithCode:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSInteger</span>)code reason:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)reason wasClean:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">BOOL</span>)wasClean
{

    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"被关闭连接，code:%ld,reason:%@,wasClean:%d"</span>,code,reason,wasClean);

    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//如果是被用户自己中断的那么直接断开连接，否则开始重连</span>     <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">if</span> (code == disConnectByUser) {
        [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> disConnect];
    }<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">else</span>{

        [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> reConnect];
    }
    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//断开连接时销毁心跳</span>     [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> destoryHeartBeat];

}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//sendPing的时候，如果网络通的话，则会收到回调，但是必须保证ScoketOpen，否则会crash</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)webSocket:(SRWebSocket *)webSocket didReceivePong:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSData</span> *)pongPayload
{
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"收到pong回调"</span>);

}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//将收到的消息，是否需要把data转换为NSString，每次收到消息都会被调用，默认YES</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//- (BOOL)webSocketShouldConvertTextFrameToString:(SRWebSocket *)webSocket</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//{</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//    NSLog(@"webSocketShouldConvertTextFrameToString");</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//    return NO;</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//}</span></code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">.m文件有点长，大家可以参照github中的demo进行阅读，这回我们添加了一些细节的东西了，包括一个简单的心跳，重连机制，还有<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">webScoket</code>封装好的一个<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">pingpong</code>机制。<br style="box-sizing:border-box;" />
代码非常简单，大家可以配合着注释读一读，应该很容易理解。<br style="box-sizing:border-box;" />
需要说一下的是这个心跳机制是一个定时的间隔，往往我们可能会有更复杂实现，比如我们正在发送消息的时候，可能就不需要心跳。当不在发送的时候在开启心跳之类的。微信有一种更高端的实现方式，有兴趣的小伙伴可以看看：<br style="box-sizing:border-box;" />
<a href="http://www.52im.net/thread-120-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">微信的智能心跳实现方式</a></p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">还有一点需要说的就是这个重连机制，demo中我采用的是2的指数级别增长，第一次立刻重连，第二次2秒，第三次4秒，第四次8秒...直到大于64秒就不再重连。而任意的一次成功的连接，都会重置这个重连时间。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">最后一点需要说的是，这个框架给我们封装的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">webscoket</code>在调用它的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">sendPing</code>方法之前，一定要判断当前<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">scoket</code>是否连接，如果不是连接状态，程序则会<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">crash</code>。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">客户端的实现就大致如此，接着同样我们需要实现一个服务端，来看看实际通讯效果。</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">webScoket服务端实现</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">在这里我们无法沿用之前的node.js例子了，因为这并不是一个原生的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">scoket</code>，这是<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">webScoket</code>，所以我们服务端同样需要遵守<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">webScoket</code>协议，两者才能实现通信。<br style="box-sizing:border-box;" />
其实这里实现也很简单，我采用了<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">node.js</code>的<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">ws</code>模块，只需要用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">npm</code>去安装<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">ws</code>即可。<br style="box-sizing:border-box;" />
什么是<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">npm</code>呢？举个例子，<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">npm</code>之于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Node.js</code>相当于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">cocospod</code>至于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">iOS</code>，它就是一个拓展模块的一个管理工具。如果不知道怎么用的可以看看这篇文章：<a href="http://www.runoob.com/nodejs/nodejs-npm.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">npm的使用</a></p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">我们进入当前脚本目录，输入终端命令，即可安装<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">ws</code>模块：</p>
<pre class="hljs cmake" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="cmake" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;">$ npm <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">install</span> ws</code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">大家如果懒得去看npm的小伙伴也没关系，直接下载github中的&nbsp;<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">WSServer.js</code>这个文件运行即可。<br style="box-sizing:border-box;" />
该源文件代码如下：</p>
<pre class="hljs javascript" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="javascript" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">var</span> WebSocketServer = <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">require</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'ws'</span>).Server,

wss = <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">new</span> WebSocketServer({ <span class="hljs-attr" style="box-sizing:border-box;">port</span>: <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">6969</span> });
wss.on(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'connection'</span>, <span class="hljs-function" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">function</span> (<span class="hljs-params" style="box-sizing:border-box;">ws</span>) </span>{
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">console</span>.log(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'client connected'</span>);

       ws.send(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'你是第'</span> + wss.clients.length + <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'位'</span>);  
    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//收到消息回调</span>     ws.on(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'message'</span>, <span class="hljs-function" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">function</span> (<span class="hljs-params" style="box-sizing:border-box;">message</span>) </span>{
        <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">console</span>.log(message);
        ws.send(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'收到:'</span>+message);  
    });

     <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">// 退出聊天  </span>     ws.on(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'close'</span>, <span class="hljs-function" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">function</span>(<span class="hljs-params" style="box-sizing:border-box;">close</span>) </span>{  

          <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">console</span>.log(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'退出连接了'</span>);  
    });  
});<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">console</span>.log(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'开始监听6969端口'</span>);</code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">代码没几行，理解起来很简单。<br style="box-sizing:border-box;" />
就是监听了本机6969端口，如果客户端连接了，打印lient connected，并且向客户端发送：你是第几位。<br style="box-sizing:border-box;" />
如果收到客户端消息后，打印消息，并且向客户端发送这条收到的消息。</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">接着我们同样来运行一下看看效果：</h6>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-410b24e854bc4a71.gif?imageMogr2/auto-orient/strip" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-410b24e854bc4a71.gif?imageMogr2/auto-orient/strip" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
</div>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><br style="box-sizing:border-box;" />
运行我们可以看到，主动去断开的连接，没有去重连，而server端断开的，我们开启了重连。感兴趣的朋友可以下载demo实际运行一下。</p>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-cbd7d436cc74d834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-cbd7d436cc74d834.png?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
<div class="image-caption" style="box-sizing:border-box;min-width:20%;max-width:80%;min-height:22px;display:inline-block;padding:10px;margin:0px auto;border-bottom:1px solid #d9d9d9;font-size:14px;color:#969696;line-height:1.7;">分割图.png</div>
</div>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">4.我们接着来看看MQTT：</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">MQTT是一个聊天协议，它比<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">webScoket</code>更上层，属于应用层。<br style="box-sizing:border-box;" />
它的基本模式是简单的发布订阅，也就是说当一条消息发出去的时候，谁订阅了谁就会受到。其实它并不适合IM的场景，例如用来实现有些简单IM场景，却需要很大量的、复杂的处理。<br style="box-sizing:border-box;" />
比较适合它的场景为订阅发布这种模式的，例如微信的实时共享位置，滴滴的地图上小车的移动、客户端推送等功能。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">首先我们来看看基于<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">MQTT</code>协议的框架-<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">MQTTKit</code>:<br style="box-sizing:border-box;" />
这个框架是c来写的，把一些方法公开在<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">MQTTKit</code>类中，对外用OC来调用，我们来看看这个类：</p>
<pre class="hljs objectivec" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="objectivec" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@interface</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">MQTTClient</span> : <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">NSObject</span> </span>{
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">struct</span> mosquitto *mosq;
}<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">readwrite</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">copy</span>) <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *clientID;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">readwrite</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">copy</span>) <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *host;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">readwrite</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">assign</span>) <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">unsigned</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">short</span> port;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">readwrite</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">copy</span>) <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *username;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">readwrite</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">copy</span>) <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *password;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">readwrite</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">assign</span>) <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">unsigned</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">short</span> keepAlive;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">readwrite</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">assign</span>) <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">BOOL</span> cleanSession;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@property</span> (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">nonatomic</span>, <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">copy</span>) MQTTMessageHandler messageHandler;

+ (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>) initialize;
+ (<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span>*) version;

- (MQTTClient*) initWithClientId: (<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)clientId;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>) setMessageRetry: (<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSUInteger</span>)seconds;<span class="hljs-meta" style="box-sizing:border-box;">#pragma mark - Connection</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>) connectWithCompletionHandler:(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span> (^)(MQTTConnectionReturnCode code))completionHandler;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>) connectToHost: (<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span>*)host
     completionHandler:(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span> (^)(MQTTConnectionReturnCode code))completionHandler;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>) disconnectWithCompletionHandler:(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span> (^)(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSUInteger</span> code))completionHandler;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>) reconnect;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)setWillData:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSData</span> *)payload
            toTopic:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)willTopic
            withQos:(MQTTQualityOfService)willQos
             <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">retain</span>:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">BOOL</span>)<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">retain</span>;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)setWill:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)payload
        toTopic:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)willTopic
        withQos:(MQTTQualityOfService)willQos
         <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">retain</span>:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">BOOL</span>)<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">retain</span>;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)clearWill;<span class="hljs-meta" style="box-sizing:border-box;">#pragma mark - Publish</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)publishData:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSData</span> *)payload
            toTopic:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)topic
            withQos:(MQTTQualityOfService)qos
             <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">retain</span>:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">BOOL</span>)<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">retain</span>   completionHandler:(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span> (^)(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> mid))completionHandler;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)publishString:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)payload
              toTopic:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)topic
              withQos:(MQTTQualityOfService)qos
               <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">retain</span>:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">BOOL</span>)<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">retain</span>     completionHandler:(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span> (^)(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> mid))completionHandler;<span class="hljs-meta" style="box-sizing:border-box;">#pragma mark - Subscribe</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)subscribe:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)topic
withCompletionHandler:(MQTTSubscriptionCompletionHandler)completionHandler;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)subscribe:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)topic
          withQos:(MQTTQualityOfService)qos
completionHandler:(MQTTSubscriptionCompletionHandler)completionHandler;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)unsubscribe: (<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)topic
withCompletionHandler:(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span> (^)(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>))completionHandler;</code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">这个类一共分为4个部分：初始化、连接、发布、订阅，具体方法的作用可以先看看方法名理解下，我们接着来用这个框架封装一个实例。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">同样，我们封装了一个单例<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">MQTTManager</code>。<br style="box-sizing:border-box;" />
<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">MQTTManager.h</code></p>
<pre class="hljs objectivec" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="objectivec" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">&lt;Foundation/Foundation.h&gt;</span></span> <span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@interface</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">MQTTManager</span> : <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">NSObject</span></span> + (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">instancetype</span>)share;

- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)connect;
- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)disConnect;

- (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)sendMsg:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)msg;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@end</span></code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">MQTTManager.m</code></p>
<pre class="hljs objectivec" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="objectivec" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">"MQTTManager.h"</span></span> <span class="hljs-meta" style="box-sizing:border-box;">#import <span class="hljs-meta-string" style="box-sizing:border-box;">"MQTTKit.h"</span></span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span>  <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> * Khost = <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"127.0.0.1"</span>;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span> <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">const</span> uint16_t Kport = <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">6969</span>;<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span>  <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> * KClientID = <span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"tuyaohui"</span>;<span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@interface</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">MQTTManager</span>()</span> {
    MQTTClient *client;

}<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@end</span> <span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@implementation</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">MQTTManager</span></span> + (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">instancetype</span>)share
{
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span> <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">dispatch_once_t</span> onceToken;
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">static</span> MQTTManager *instance = <span class="hljs-literal" style="box-sizing:border-box;">nil</span>;
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">dispatch_once</span>(&amp;onceToken, ^{
        instance = [[<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> alloc]init];
    });
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">return</span> instance;
}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//初始化连接</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)initSocket
{
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">if</span> (client) {
        [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> disConnect];
    }


    client = [[MQTTClient alloc] initWithClientId:KClientID];
    client.port = Kport;

    [client setMessageHandler:^(MQTTMessage *message)
     {
         <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//收到消息的回调，前提是得先订阅</span>          <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *msg = [[<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> alloc]initWithData:message.payload encoding:<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSUTF8StringEncoding</span>];

         <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"收到服务端消息：%@"</span>,msg);

     }];

    [client connectToHost:Khost completionHandler:^(MQTTConnectionReturnCode code) {

        <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">switch</span> (code) {
            <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">case</span> ConnectionAccepted:
                <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"MQTT连接成功"</span>);
                <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//订阅自己ID的消息，这样收到消息就能回调</span>                 [client subscribe:client.clientID withCompletionHandler:^(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSArray</span> *grantedQos) {

                    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"订阅tuyaohui成功"</span>);
                }];

                <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">break</span>;

            <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">case</span> ConnectionRefusedBadUserNameOrPassword:

                <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"错误的用户名密码"</span>);

            <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//....</span>             <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">default</span>:
                <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"MQTT连接失败"</span>);

                <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">break</span>;
        }

    }];
}<span class="hljs-meta" style="box-sizing:border-box;">#pragma mark - 对外的一些接口</span> <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//建立连接</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)connect
{
    [<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">self</span> initSocket];
}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//断开连接</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)disConnect
{
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">if</span> (client) {
        <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//取消订阅</span>         [client unsubscribe:client.clientID withCompletionHandler:^{
            <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"取消订阅tuyaohui成功"</span>);

        }];
        <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//断开连接</span>         [client disconnectWithCompletionHandler:^(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSUInteger</span> code) {

            <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSLog</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">@"断开MQTT成功"</span>);

        }];

        client = <span class="hljs-literal" style="box-sizing:border-box;">nil</span>;
    }
}<span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//发送消息</span> - (<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">void</span>)sendMsg:(<span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">NSString</span> *)msg
{
    <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">//发送一条消息，发送给自己订阅的主题</span>     [client publishString:msg toTopic:KClientID withQos:ExactlyOnce <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">retain</span>:<span class="hljs-literal" style="box-sizing:border-box;">YES</span> completionHandler:^(<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">int</span> mid) {

    }];
}<span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">@end</span></code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">实现代码很简单，需要说一下的是：<br style="box-sizing:border-box;" />
1）当我们连接成功了，我们需要去订阅自己<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">clientID</code>的消息，这样才能收到发给自己的消息。<br style="box-sizing:border-box;" />
2）其次是这个框架为我们实现了一个QOS机制，那么什么是QOS呢？</p>
<blockquote style="box-sizing:border-box;padding:20px;margin:0px 0px 25px;border-left-width:6px;border-left-style:solid;border-left-color:#b4b4b4;background-color:#f7f7f7;word-break:break-word;line-height:30px;"><p style="box-sizing:border-box;margin-top:0px;margin-bottom:0px;word-break:break-word;line-height:1.7;">QoS（Quality of Service，<a href="http://baike.baidu.com/view/522662.htm" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">服务质量</a>）指一个网络能够利用各种基础技术，为指定的<a href="http://baike.baidu.com/view/538641.htm" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">网络通信</a>提供更好的服务能力, 是网络的一种安全机制， 是用来解决网络延迟和阻塞等问题的一种技术。</p>
</blockquote>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">在这里，它提供了三个选项：</p>
<pre class="hljs crystal" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="crystal" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;">typedef <span class="hljs-class" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">enum</span> <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">MQTTQualityOfService</span> : <span class="hljs-title" style="box-sizing:border-box;color:#b58900;">NSUInteger</span> {</span>     AtMostOnce,
    AtLeastOnce,
    ExactlyOnce
} MQTTQualityOfService;</code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">分别对应最多发送一次，至少发送一次，精确只发送一次。</p>
<ul style="box-sizing:border-box;margin-top:0px;margin-bottom:20px;padding:0px;word-break:break-word;margin-left:22px;"><li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">QOS(0),最多发送一次：如果消息没有发送过去，那么就直接丢失。</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">QOS(1),至少发送一次：保证消息一定发送过去，但是发几次不确定。</li>
<li style="box-sizing:border-box;line-height:30px;margin-bottom:10px;">QOS(2),精确只发送一次：它内部会有一个很复杂的发送机制，确保消息送到，而且只发送一次。</li>
</ul>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">更详细的关于该机制可以看看这篇文章：<a href="http://www.blogjava.net/yongboy/archive/2014/02/15/409893.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">MQTT协议笔记之消息流QOS</a>。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">同样的我们需要一个用MQTT协议实现的服务端，我们还是node.js来实现，这次我们还是需要用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">npm</code>来新增一个模块<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">mosca</code>。<br style="box-sizing:border-box;" />
我们来看看服务端代码：<br style="box-sizing:border-box;" />
<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">MQTTServer.js</code></p>
<pre class="hljs javascript" style="box-sizing:border-box;overflow:auto;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;padding:15px;margin-top:0px;margin-bottom:20px;line-height:1.42857;word-break:break-word;word-wrap:normal;color:#657b83;background-color:#f6f6f6;border:1px solid #cccccc;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;background-position:initial initial;background-repeat:initial initial;"><code class="javascript" style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:12px;background-color:transparent;border-top-left-radius:0px;border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:0px;padding:0px;border:none;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">var</span> mosca = <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">require</span>(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'mosca'</span>);  <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">var</span> MqttServer = <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">new</span> mosca.Server({  
    <span class="hljs-attr" style="box-sizing:border-box;">port</span>: <span class="hljs-number" style="box-sizing:border-box;color:#2aa198;">6969</span>  
});  

MqttServer.on(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'clientConnected'</span>, <span class="hljs-function" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">function</span>(<span class="hljs-params" style="box-sizing:border-box;">client</span>)</span>{  
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">console</span>.log(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'收到客户端连接，连接ID：'</span>, client.id);  
});  <span class="hljs-comment" style="box-sizing:border-box;color:#93a1a1;">/** 
 * 监听MQTT主题消息 
 **/</span>  
MqttServer.on(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'published'</span>, <span class="hljs-function" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">function</span>(<span class="hljs-params" style="box-sizing:border-box;">packet, client</span>) </span>{  
    <span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">var</span> topic = packet.topic;  
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">console</span>.log(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'有消息来了'</span>,<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'topic为：'</span>+topic+<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">',message为：'</span>+ packet.payload.toString());  

});  

MqttServer.on(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'ready'</span>, <span class="hljs-function" style="box-sizing:border-box;"><span class="hljs-keyword" style="box-sizing:border-box;color:#859900;">function</span>()</span>{  
    <span class="hljs-built_in" style="box-sizing:border-box;color:#268bd2;">console</span>.log(<span class="hljs-string" style="box-sizing:border-box;color:#2aa198;">'mqtt服务器开启，监听6969端口'</span>);  
});</code></pre><p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">服务端代码没几行，开启了一个服务，并且监听本机6969端口。并且监听了客户端连接、发布消息等状态。</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">接着我们同样来运行一下看看效果：</h6>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-beec3a4437a7d6db.gif?imageMogr2/auto-orient/strip" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-beec3a4437a7d6db.gif?imageMogr2/auto-orient/strip" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
</div>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">至此，我们实现了一个简单的MQTT封装。</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">5.XMPP：XMPPFramework框架</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">结果就是并没有XMPP...因为个人感觉XMPP对于IM来说实在是不堪重用。仅仅只能作为一个玩具demo，给大家练练手。网上有太多XMPP的内容了，相当一部分用openfire来做服务端，这一套东西实在是太老了。还记得多年前，楼主初识IM就是用的这一套东西...<br style="box-sizing:border-box;" />
如果大家仍然感兴趣的可以看看这篇文章：<a href="http://www.cocoachina.com/ios/20141219/10703.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">iOS 的 XMPPFramework 简介</a>。这里就不举例赘述了。</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">三、关于IM传输格式的选择：</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">引用陈宜龙大神文章（<a href="http://www.jianshu.com/users/96a14318a4de/latest_articles" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">iOS程序犭袁&nbsp;</a>）中一段：<br style="box-sizing:border-box;" />
<span style="box-sizing:border-box;font-weight:700;">使用 ProtocolBuffer 减少 Payload</span><br style="box-sizing:border-box;" />
滴滴打车40%；<br style="box-sizing:border-box;" />
携程之前分享过，说是采用新的Protocol Buffer数据格式+Gzip压缩后的Payload大小降低了15%-45%。数据序列化耗时下降了80%-90%。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">采用高效安全的私有协议，支持长连接的复用，稳定省电省流量<br style="box-sizing:border-box;" />
【高效】提高网络请求成功率，消息体越大，失败几率随之增加。<br style="box-sizing:border-box;" />
【省流量】流量消耗极少，省流量。一条消息数据用Protobuf序列化后的大小是 JSON 的1/10、XML格式的1/20、是二进制序列化的1/10。同 XML 相比， Protobuf 性能优势明显。它以高效的二进制方式存储，比 XML 小 3 到 10 倍，快 20 到 100 倍。<br style="box-sizing:border-box;" />
【省电】省电<br style="box-sizing:border-box;" />
【高效心跳包】同时心跳包协议对IM的电量和流量影响很大，对心跳包协议上进行了极简设计：仅 1 Byte 。<br style="box-sizing:border-box;" />
【易于使用】开发人员通过按照一定的语法定义结构化的消息格式，然后送给命令行工具，工具将自动生成相关的类，可以支持java、c++、python、Objective-C等语言环境。通过将这些类包含在项目中，可以很轻松的调用相关方法来完成业务消息的序列化与反序列化工作。语言支持：原生支持c++、java、python、Objective-C等多达10余种语言。 2015-08-27 Protocol Buffers v3.0.0-beta-1中发布了Objective-C(Alpha)版本， 2016-07-28 3.0 Protocol Buffers v3.0.0正式版发布，正式支持 Objective-C。<br style="box-sizing:border-box;" />
【可靠】微信和手机 QQ 这样的主流 IM 应用也早已在使用它（采用的是改造过的Protobuf协议）</p>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-3c314239bfa0baea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-3c314239bfa0baea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
</div>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">如何测试验证 Protobuf 的高性能？<br style="box-sizing:border-box;" />
对数据分别操作100次，1000次，10000次和100000次进行了测试，<br style="box-sizing:border-box;" />
纵坐标是完成时间，单位是毫秒，<br style="box-sizing:border-box;" />
反序列化<br style="box-sizing:border-box;" />
序列化<br style="box-sizing:border-box;" />
字节长度</p>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-f6b9826dc377a278.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-f6b9826dc377a278.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
</div>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-9671c7c62a2d9462.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-9671c7c62a2d9462.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
</div>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-3768d8ba7cb21291.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-3768d8ba7cb21291.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
</div>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;"><a href="http://www.cnblogs.com/beyondbit/p/4778264.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">数据来源</a>。<br style="box-sizing:border-box;" />
</p>
<div class="image-package" style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;"><img src="http://upload-images.jianshu.io/upload_images/2702646-356bf2a501d04177.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-original-src="http://upload-images.jianshu.io/upload_images/2702646-356bf2a501d04177.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" style="box-sizing:border-box;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;transition:all 0.25s ease-in-out;-webkit-transition:all 0.25s ease-in-out;" /><br style="box-sizing:border-box;" />
</div>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">数据来自：项目&nbsp;<a href="https://github.com/eishay/jvm-serializers/wiki" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">thrift-protobuf-compare</a>，测试项为 Total Time，也就是 指一个对象操作的整个时间，包括创建对象，将对象序列化为内存中的字节序列，然后再反序列化的整个过程。从测试结果可以看到 Protobuf 的成绩很好.<br style="box-sizing:border-box;" />
缺点：<br style="box-sizing:border-box;" />
可能会造成 APP 的包体积增大，通过 Google 提供的脚本生成的 Model，会非常“庞大”，Model 一多，包体积也就会跟着变大。<br style="box-sizing:border-box;" />
如果 Model 过多，可能导致 APP 打包后的体积骤增，但 IM 服务所使用的 Model 非常少，比如在 ChatKit-OC 中只用到了一个 Protobuf 的 Model：Message对象，对包体积的影响微乎其微。<br style="box-sizing:border-box;" />
在使用过程中要合理地权衡包体积以及传输效率的问题，据说去哪儿网，就曾经为了减少包体积，进而减少了 Protobuf 的使用。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">综上所述，我们选择传输格式的时候：<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">ProtocolBuffer</code>&nbsp;&gt;&nbsp;<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">Json</code>&nbsp;&gt;&nbsp;<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">XML</code></p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">如果大家对<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">ProtocolBuffer</code>用法感兴趣可以参考下这两篇文章：<br style="box-sizing:border-box;" />
<a href="http://www.jianshu.com/p/8c6c009bc500" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">ProtocolBuffer for Objective-C 运行环境配置及使用&nbsp;</a><br style="box-sizing:border-box;" />
<a href="http://www.qingpingshan.com/rjbc/ios/181571.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">iOS之ProtocolBuffer搭建和示例demo</a></p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">三、IM一些其它问题</h6>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">1.IM的可靠性：</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">我们之前穿插在例子中提到过：<br style="box-sizing:border-box;" />
心跳机制、PingPong机制、断线重连机制、还有我们后面所说的QOS机制。这些被用来保证连接的可用，消息的即时与准确的送达等等。<br style="box-sizing:border-box;" />
上述内容保证了我们IM服务时的可靠性，其实我们能做的还有很多：比如我们在大文件传输的时候使用分片上传、断点续传、秒传技术等来保证文件的传输。</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">2.安全性：</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">我们通常还需要一些安全机制来保证我们IM通信安全。<br style="box-sizing:border-box;" />
例如：<a href="https://github.com/ChenYilong/iOSBlog/blob/master/Tips/%E5%9F%BA%E4%BA%8EWebsocket%E7%9A%84IM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E6%8A%80%E6%9C%AF/%E9%98%B2%20DNS%20%E6%B1%A1%E6%9F%93%E6%96%B9%E6%A1%88.md" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">防止 DNS 污染</a>、帐号安全、第三方服务器鉴权、单点登录等等</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">3.一些其他的优化：</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">类似微信，服务器不做聊天记录的存储，只在本机进行缓存，这样可以减少对服务端数据的请求，一方面减轻了服务器的压力，另一方面减少客户端流量的消耗。<br style="box-sizing:border-box;" />
我们进行http连接的时候尽量采用上层API，类似<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">NSUrlSession</code>。而网络框架尽量使用<code style="box-sizing:border-box;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:#657b83;background-color:#f6f6f6;border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;">AFNetWorking3</code>。因为这些上层网络请求都用的是HTTP/2 ，我们请求的时候可以复用这些连接。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">更多优化相关内容可以参考参考这篇文章：<br style="box-sizing:border-box;" />
<a href="http://www.jianshu.com/p/8cd908148f9e" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">IM 即时通讯技术在多应用场景下的技术实现，以及性能调优</a></p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">四、音视频通话</h6>
<blockquote style="box-sizing:border-box;padding:20px;margin:0px 0px 25px;border-left-width:6px;border-left-style:solid;border-left-color:#b4b4b4;background-color:#f7f7f7;word-break:break-word;line-height:30px;"><p style="box-sizing:border-box;margin-top:0px;margin-bottom:0px;word-break:break-word;line-height:1.7;">IM应用中的实时音视频技术，几乎是IM开发中的最后一道高墙。原因在于：实时音视频技术 = 音视频处理技术 + 网络传输技术 的横向技术应用集合体，而公共互联网不是为了实时通信设计的。<br style="box-sizing:border-box;" />
实时音视频技术上的实现内容主要包括：音视频的采集、编码、网络传输、解码、播放等环节。这么多项并不简单的技术应用，如果把握不当，将会在在实际开发过程中遇到一个又一个的坑。</p>
</blockquote>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">因为楼主自己对这块的技术理解很浅，所以引用了一个系列的文章来给大家一个参考，感兴趣的朋友可以看看：<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-228-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（一）：视频编解码之理论概述</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-229-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（二）：视频编解码之数字视频介绍</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-232-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（三）：视频编解码之编码基础</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-235-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（四）：视频编解码之预测技术介绍</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-237-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（五）：认识主流视频编码技术H.264</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-241-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（六）：如何开始音频编解码技术的学习</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-242-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（七）：音频基础及编码原理入门</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-243-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（八）：常见的实时语音通讯编码标准</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-247-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（九）：实时语音通讯的回音及回音消除概述</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-250-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（十）：实时语音通讯的回音消除技术详解</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-251-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（十一）：实时语音通讯丢包补偿技术详解</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-253-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（十二）：多人实时音视频聊天架构探讨</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-266-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（十三）：实时视频编码H.264的特点与优势</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-267-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（十四）：实时音视频数据传输协议介绍</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-269-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（十五）：聊聊P2P与实时音视频的应用情况</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-270-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（十六）：移动端实时音视频开发的几个建议</a>》<br style="box-sizing:border-box;" />
《<a href="http://www.52im.net/thread-274-1-1.html" target="_blank" style="box-sizing:border-box;background-color:transparent;color:#3194d0;text-decoration:none;cursor:pointer;">即时通讯音视频开发（十七）：视频编码H.264、V8的前世今生</a>》</p>
<h6 style="box-sizing:border-box;font-family:inherit;line-height:1.7;margin:0px 0px 15px;font-size:16px;text-rendering:optimizelegibility;">写在最后：</h6>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:25px;word-break:break-word;">本文内容为原创，且仅代表楼主现阶段的一些思想，如果有什么错误，欢迎指正~</p>
</div></body></html>