<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content=mNote Mac 2.5.11"/><meta name="created" content="2016-10-10T11:04:19Z"/><meta name="updated" content="2016-10-10T11:04:21Z"/><title>最近因为忙于工作，没时间整理，本篇是下班后晚上抽空整理的，文中部分答案本来是想自己好好整理一份的，但是时间真的很紧，所以就整理了一下网络上的文章链接，挑了写的不错的文章，后续有时间补上来。后续答案也</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">最近因为忙于工作，没时间整理，本篇是下班后晚上抽空整理的，文中部分答案本来是想自己好好整理一份的，但是时间真的很紧，所以就整理了一下网络上的文章链接，挑了写的不错的文章，后续有时间补上来。后续答案也会在Java分享微信公众号：JavaQ 中给出，欢迎大家围观哦！</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">1.面向对象和面向过程的区别<br style="box-sizing:border-box;" />
面向过程<br style="box-sizing:border-box;" />
优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br style="box-sizing:border-box;" />
缺点：没有面向对象易维护、易复用、易扩展</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">后续答案也会在Java分享微信公众号：JavaQ 中给出，欢迎大家围观哦！</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">面向对象<br style="box-sizing:border-box;" />
优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护<br style="box-sizing:border-box;" />
缺点：性能比面向过程低</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">2.Java的四个基本特性（抽象、封装、继承，多态）</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">抽象：就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。抽象包括两个方面：一个是数据抽象，一个是过程抽象。数据抽象也就是对象的属性。过程抽象是对象的行为特征。<br style="box-sizing:border-box;" />
封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行封装隐藏。封装分为属性的封装和方法的封装。<br style="box-sizing:border-box;" />
继承：是对有着共同特性的多类事物，进行再抽象成一个类。这个类就是多类事物的父类。父类的意义在于抽取多类事物的共性。<br style="box-sizing:border-box;" />
多态：允许不同类的对象对同一消息做出响应。方法的重载、类的覆盖正体现了多态。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">3.重载和重写的区别<br style="box-sizing:border-box;" />
重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。<br style="box-sizing:border-box;" />
重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">4.构造器Constructor是否可被override<br style="box-sizing:border-box;" />
构造器不能被重写，不能用static修饰构造器，只能用 public private protected这三个权限修饰符，且不能有返回语句。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">5.访问控制符public,protected,private,以及默认的区别<br style="box-sizing:border-box;" />
private只有在本类中才能访问；<br style="box-sizing:border-box;" />
public在任何地方都能访问；<br style="box-sizing:border-box;" />
protected在同包内的类及包外的子类能访问；<br style="box-sizing:border-box;" />
默认不写在同包内能访问。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">6.是否可以继承String类<br style="box-sizing:border-box;" />
String类是final类故不可以继承，一切由final修饰过的都不能继承</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">7.String和StringBuffer、StringBuilder的区别</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">可变性：<br style="box-sizing:border-box;" />
String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。<br style="box-sizing:border-box;" />
StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。<br style="box-sizing:border-box;" />
线程安全性：<br style="box-sizing:border-box;" />
String中的对象是不可变的，也就可以理解为常量，线程安全。<br style="box-sizing:border-box;" />
AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。<br style="box-sizing:border-box;" />
性能：<br style="box-sizing:border-box;" />
每次对String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">8.hashCode和equals方法的关系<br style="box-sizing:border-box;" />
equals相等，hashcode必相等；hashcode相等，equals可能不相等。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">9.抽象类和接口的区别<br style="box-sizing:border-box;" />
语法层次：<br style="box-sizing:border-box;" />
抽象类和接口分别给出了不同的语法定义<br style="box-sizing:border-box;" />
设计层次：<br style="box-sizing:border-box;" />
抽象层次不同，抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。<br style="box-sizing:border-box;" />
跨域不同，抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的，仅仅是实现了接口定义的契约而已，”like-a”的关系。。<br style="box-sizing:border-box;" />
设计层次不同，抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">10.自动装箱与拆箱<br style="box-sizing:border-box;" />
装箱：将基本类型用它们对应的引用类型包装起来；<br style="box-sizing:border-box;" />
拆箱：将包装类型转换为基本数据类型；<br style="box-sizing:border-box;" />
Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">11.什么是泛型、为什么要使用以及泛型擦除<br style="box-sizing:border-box;" />
泛型，即“参数化类型”。<br style="box-sizing:border-box;" />
创建集合时就指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。<br style="box-sizing:border-box;" />
Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程即类型擦除。 泛型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。<br style="box-sizing:border-box;" />
类型擦除的主要过程如下：<br style="box-sizing:border-box;" />
一.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。<br style="box-sizing:border-box;" />
二.移除所有的类型参数。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">12.Java中的集合类及关系图<br style="box-sizing:border-box;" />
List和Set继承自Collection接口。<br style="box-sizing:border-box;" />
Set无序不允许元素重复。HashSet和TreeSet是两个主要的实现类。<br style="box-sizing:border-box;" />
List有序且允许元素重复。ArrayList、LinkedList和Vector是三个主要的实现类。<br style="box-sizing:border-box;" />
Map也属于集合系统，但和Collection接口没关系。Map是key对value的映射集合，其中key列就是一个集合。key不能重复，但是value可以重复。 HashMap、TreeMap和Hashtable是三个主要的实现类。<br style="box-sizing:border-box;" />
SortedSet和SortedMap接口对元素按指定规则排序，SortedMap是对key列进行排序。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">13.HashMap实现原理<br style="box-sizing:border-box;" />
具体原理一句两句也说不清楚，网络文章：<br style="box-sizing:border-box;" />
<a target="_blank" href="http://zhangshixi.iteye.com/blog/672697" style="box-sizing:border-box;color:#58b0d5;text-decoration:none;transition:color 300ms ease;background:transparent;">http://zhangshixi.iteye.com/blog/672697</a><br style="box-sizing:border-box;" />
<a target="_blank" href="http://www.importnew.com/7099.html" style="box-sizing:border-box;color:#58b0d5;text-decoration:none;transition:color 300ms ease;background:transparent;">http://www.importnew.com/7099.html</a></p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">14.HashTable实现原理<br style="box-sizing:border-box;" />
具体原理一句两句也说不清楚，网络文章：<br style="box-sizing:border-box;" />
<a target="_blank" href="http://www.cnblogs.com/skywang12345/p/3310887.html" style="box-sizing:border-box;color:#58b0d5;text-decoration:none;transition:color 300ms ease;background:transparent;">http://www.cnblogs.com/skywang12345/p/3310887.html</a><a target="_blank" href="http://blog.csdn.net/chdjj/article/details/38581035" style="box-sizing:border-box;color:#58b0d5;text-decoration:none;transition:color 300ms ease;background:transparent;">http://blog.csdn.net/chdjj/article/details/38581035</a></p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">15.HashMap和HashTable区别<br style="box-sizing:border-box;" />
一.HashTable的方法前面都有synchronized来同步，是线程安全的；HashMap未经同步，是非线程安全的。<br style="box-sizing:border-box;" />
二.HashTable不允许null值(key和value都不可以) ；HashMap允许null值(key和value都可以)。<br style="box-sizing:border-box;" />
三.HashTable有一个contains(Object value)功能和containsValue(Object value)功能一样。<br style="box-sizing:border-box;" />
四.HashTable使用Enumeration进行遍历；HashMap使用Iterator进行遍历。<br style="box-sizing:border-box;" />
五.HashTable中hash数组默认大小是11，增加的方式是 old*2+1；HashMap中hash数组的默认大小是16，而且一定是2的指数。<br style="box-sizing:border-box;" />
六.哈希值的使用不同，HashTable直接使用对象的hashCode； HashMap重新计算hash值，而且用与代替求模。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">16.ArrayList和vector区别<br style="box-sizing:border-box;" />
ArrayList和 Vector都实现了List接口， 都是通过数组实现的。<br style="box-sizing:border-box;" />
Vector是线程安全的，而ArrayList是非线程安全的。<br style="box-sizing:border-box;" />
List第一次创建的时候，会有一个初始大小，随着不断向List中增加元素，当 List 认为容量不够的时候就会进行扩容。Vector缺省情况下自动增长原来一倍的数组长度，ArrayList增长原来的50%。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">17.ArrayList和LinkedList区别及使用场景<br style="box-sizing:border-box;" />
ArrayList底层是用数组实现的，可以认为ArrayList是一个可改变大小的数组。随着越来越多的元素被添加到ArrayList中，其规模是动态增加的。<br style="box-sizing:border-box;" />
LinkedList底层是通过双向链表实现的， LinkedList和ArrayList相比，增删的速度较快。但是查询和修改值的速度较慢。同时，LinkedList还实现了Queue接口，所以他还提供了offer(), peek(), poll()等方法。<br style="box-sizing:border-box;" />
LinkedList更适合从中间插入或者删除（链表的特性）。 ArrayList更适合检索和在末尾插入或删除（数组的特性）。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">18.Collection和Collections的区别<br style="box-sizing:border-box;" />
java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。<br style="box-sizing:border-box;" />
java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">19.Concurrenthashmap实现原理<br style="box-sizing:border-box;" />
具体原理一句两句也说不清楚，网络文章：<br style="box-sizing:border-box;" />
<a target="_blank" href="http://www.cnblogs.com/ITtangtang/p/3948786.html" style="box-sizing:border-box;color:#58b0d5;text-decoration:none;transition:color 300ms ease;background:transparent;">http://www.cnblogs.com/ITtangtang/p/3948786.html</a><br style="box-sizing:border-box;" />
<a target="_blank" href="http://ifeve.com/concurrenthashmap/" style="box-sizing:border-box;color:#58b0d5;text-decoration:none;transition:color 300ms ease;background:transparent;">http://ifeve.com/concurrenthashmap/</a></p>
<p style="box-sizing:border-box;margin-top:0px;margin-bottom:10px;color:#2e2e2e;font-family:'Microsoft YaHei', 宋体, Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:15px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:24px;widows:1;">20.Error、Exception区别<br style="box-sizing:border-box;" />
Error类和Exception类的父类都是throwable类，他们的区别是：<br style="box-sizing:border-box;" />
Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。<br style="box-sizing:border-box;" />
Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。</p></body></html>