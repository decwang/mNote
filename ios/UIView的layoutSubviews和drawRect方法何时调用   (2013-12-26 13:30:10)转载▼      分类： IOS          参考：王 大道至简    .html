<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content=mNote Mac 2.5.11"/><meta name="created" content="2015-04-20T09:54:10Z"/><meta name="updated" content="2015-04-20T09:54:12Z"/><title>UIView的layoutSubviews和drawRect方法何时调用   (2013-12-26 13:30:10)转载▼      分类： IOS          参考：王 大道至简    </title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div class="articalTitle" style="clear:both;line-height:20px;padding-bottom:10px;color:#444444;font-family:Verdana, 宋体, sans-serif;font-size:12px;"><h2 id="t_afb4d07f0101iamg" class="titName SG_txta" style="margin:0px;padding:0px;border:0px;list-style:none;color:#0063b1;font-size:18px;font-family:微软雅黑, 黑体;font-weight:300;display:inline;">UIView的layoutSubviews和drawRect方法何时调用</h2>
&nbsp;<span class="time SG_txtc" style="color:#909090;white-space:nowrap;font-family:Arial;font-size:10px;margin-left:5px;margin-right:13px;">(2013-12-26 13:30:10)</span><div class="turnBoxzz" style="float:right;"><a class="SG_aBtn SG_aBtn_ico SG_turn" action-type="reblog" action-data="{srcBlog:1, blogId:'afb4d07f0101iamg'}" style="color:#333333;cursor:pointer;padding:0px 0px 0px 3px;overflow:hidden;white-space:nowrap;display:inline-block;margin-right:6px;background-image:url(http://simg.sinajs.cn/blog7newtpl/image/8/8_49/images/sg_newsp.png);position:relative;letter-spacing:5px;width:86px;zoom:1;background-position:0px 0px;background-repeat:no-repeat no-repeat;"><cite style="font-style:normal;line-height:23px;padding:0px 20px 0px 32px;height:23px;min-width:1px;overflow-x:visible;background-image:url(http://simg.sinajs.cn/blog7newtpl/image/8/8_49/images/sg_newsp.png);width:34px;display:inline-block !important;background-position:100% -28px;background-repeat:no-repeat no-repeat;"><img class="SG_icon SG_icon111" src="http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif" width="15" height="15" align="absmiddle" style="margin:0px;padding:0px;border:0px;list-style:none;background-image:url(http://simg.sinajs.cn/blog7style/images/common/sg_icon.png?20131218);position:absolute;left:11px;top:4px;background-position:495px -60px;" />转载<span class="arrow" style="font-size:7px;position:absolute;right:5px;top:2px;">▼</span></cite></a></div>
</div>
<div class="articalTag" id="sina_keyword_ad_area" style="width:690px;clear:both;word-break:break-all;line-height:20px;color:#444444;font-family:Verdana, 宋体, sans-serif;font-size:12px;"><table style="margin:0px;padding:0px;"><tbody><tr><td class="blog_tag" style="margin:0px;padding:0px 10px 0px 0px;font-family:宋体;vertical-align:top;"></td>
<td class="blog_class" style="margin:0px;padding:0px;font-family:宋体;vertical-align:top;width:220px;white-space:nowrap;"><span class="SG_txtb" style="color:#909090;">分类：</span>&nbsp;<a target="_blank" href="http://blog.sina.com.cn/s/articlelist_2947862655_1_1.html" style="text-decoration:none;color:#0063b1;">IOS</a></td>
</tr>
</tbody>
</table>
</div>
<div id="sina_keyword_ad_area2" class="articalContent " style="width:690px;clear:both;padding-top:18px;padding-bottom:30px;overflow:hidden;font-family:simsun;word-wrap:normal;word-break:normal;line-height:21px;color:#444444;">参考：<a href="http://jianyu996.blog.163.com/blog/static/112114555201305113018814/" target="_blank" style="text-decoration:none;color:#0063b1;">王 大道至简</a><div>&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;<wbr><a href="http://lcl130.iteye.com/blog/1855087" target="_blank" style="text-decoration:none;color:#0063b1;">lcl130</a><br />
<div><br />
</div>
<div><span style="word-wrap:normal;word-break:normal;">setNeedsDisplay</span>和<span style="word-wrap:normal;word-break:normal;">setNeedsLayout两个方法都是异步的，</span><span style="word-wrap:normal;word-break:normal;">setNeedsDisplay会自动调用</span><span style="word-wrap:normal;word-break:normal;color:#333333;">drawRect，而</span><span style="word-wrap:normal;word-break:normal;">setNeedsLayout会自动调用</span><span style="word-wrap:normal;word-break:normal;color:#333333;">layoutSubviews。</span></div>
<div><span style="word-wrap:normal;word-break:normal;color:#333333;"><br />
</span></div>
<div><span style="word-wrap:normal;word-break:normal;line-height:24px;color:#7f7f7f;"><span style="word-wrap:normal;word-break:normal;font-family:'Comic sans Ms';"><span style="word-wrap:normal;word-break:normal;color:#333333;">layoutSubviews方便数据计算，drawRect方便视图重绘。</span></span></span></div>
<div><span style="word-wrap:normal;word-break:normal;line-height:24px;color:#7f7f7f;"><span style="word-wrap:normal;word-break:normal;font-family:'Comic sans Ms';"><span style="word-wrap:normal;word-break:normal;color:#333333;"><br />
</span></span></span></div>
<div><span style="word-wrap:normal;word-break:normal;line-height:25px;font-family:Helvetica, Tahoma, Arial, sans-serif;">假设我们采用的是直接调用drawRect的机制，先考虑这样一个问题 ,，现在有两个UIViewController A和B,A为当前view的viewController，如果此时在A中调用［B.view drawRect]，这样B的view无论如何都会调用drawRect的方法重新绘制一遍，这样问题就出来了，有必要吗，毕竟现在显示的是A中的view!B重新绘制一遍就调用了drawRect中的方法，完全是在浪费系统资源啊，而通过setNeedsDisplay,ios就会很聪明的判断出不需要调用drawRect的方法，这样就避免了资源的重复调用！&nbsp;<wbr></span><br style="font-family:Helvetica, Tahoma, Arial, sans-serif;line-height:25px;" />
<span style="word-wrap:normal;word-break:normal;line-height:25px;font-family:Helvetica, Tahoma, Arial, sans-serif;">&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;同理，setNeedsLayout也采用了同样的机制来避免资源的重复利用！&nbsp;<wbr></span></div>
<div><div style="word-wrap:break-word;margin:15px 0px;padding:5px 0px;overflow:hidden;font-family:'Hiragino sans GB W3', 'Hiragino sans GB', Arial, Helvetica, simsun, u5b8bu4f53;"><p style="margin-top:0px;margin-bottom:10px;padding:0px;border:0px;list-style:none;word-wrap:normal;word-break:normal;line-height:28px;color:#7f7f7f;font-size:16px;">&nbsp;<wbr></p>
<div style="color:#7f7f7f;font-size:16px;line-height:28px;"><span style="word-wrap:normal;word-break:normal;line-height:24px;font-size:14px;"><span style="word-wrap:normal;word-break:normal;font-family:'Comic sans Ms';"><span style="word-wrap:normal;word-break:normal;color:#333333;">layoutSubviews在以下情况下会被调用：</span></span></span></div>
<p style="margin-top:0pt;margin-bottom:0pt;padding:0px;border:0px;list-style:none;word-wrap:normal;word-break:normal;line-height:28px;color:#7f7f7f;font-size:16px;">&nbsp;<wbr></p>
<div style="color:#7f7f7f;font-size:16px;line-height:28px;"><span style="word-wrap:normal;word-break:normal;line-height:24px;font-size:14px;"><span style="word-wrap:normal;word-break:normal;font-family:'Comic sans Ms';"><span style="word-wrap:normal;word-break:normal;color:#333333;">1、init初始化不会触发layoutSubviews。</span><br />
<span style="word-wrap:normal;word-break:normal;color:#333333;">2、addSubview会触发layoutSubviews。</span><br />
<span style="word-wrap:normal;word-break:normal;color:#333333;">3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。</span><br />
<span style="word-wrap:normal;word-break:normal;color:#333333;">4、滚动一个UIScrollView会触发layoutSubviews。</span><br />
<span style="word-wrap:normal;word-break:normal;color:#333333;">5、旋转Screen会触发父UIView上的layoutSubviews事件。</span><br />
<span style="word-wrap:normal;word-break:normal;color:#333333;">6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。</span></span></span></div>
<div style="color:#7f7f7f;font-size:16px;line-height:28px;"><span style="word-wrap:normal;word-break:normal;line-height:24px;font-size:14px;"><span style="word-wrap:normal;word-break:normal;font-family:'Comic sans Ms';">7、直接调用setLayoutSubviews。</span></span></div>
<div style="color:#7f7f7f;font-size:16px;line-height:28px;"><span style="word-wrap:normal;word-break:normal;line-height:24px;font-size:14px;"><span style="word-wrap:normal;word-break:normal;font-family:'Comic sans Ms';"><br />
</span></span></div>
<div style="color:#7f7f7f;font-size:16px;line-height:28px;"><span style="word-wrap:normal;word-break:normal;line-height:24px;font-size:14px;"><span style="word-wrap:normal;word-break:normal;font-family:'Comic sans Ms';">drawRect在以下情况下会被调用：</span></span></div>
<p style="margin-top:0pt;margin-bottom:0pt;padding:0px;border:0px;list-style:none;word-wrap:normal;word-break:normal;line-height:28px;color:#7f7f7f;font-size:16px;">&nbsp;<wbr></p>
<div style="color:#7f7f7f;font-size:16px;line-height:28px;"><span style="word-wrap:normal;word-break:normal;line-height:24px;font-size:14px;"><span style="word-wrap:normal;word-break:normal;font-family:'Comic sans Ms';"><span style="word-wrap:normal;word-break:normal;color:#333333;">1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。</span><span style="word-wrap:normal;word-break:normal;color:#333333;">drawRect 掉用是在Controller-&gt;loadView,&nbsp;<wbr>Controller-&gt;viewDidLoad&nbsp;<wbr>两方法之后掉用的.所以不用担心在 控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View&nbsp;<wbr>draw的时候需要用到某些变量 值).</span><span style="word-wrap:normal;word-break:normal;color:#333333;"><br />
</span><span style="word-wrap:normal;word-break:normal;color:#333333;">2、该方法在调用sizeT</span><span style="word-wrap:normal;word-break:normal;color:#333333;">o</span><span style="word-wrap:normal;word-break:normal;color:#333333;">Fit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。</span><br />
<span style="word-wrap:normal;word-break:normal;color:#333333;">3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。</span><br />
<span style="word-wrap:normal;word-break:normal;color:#333333;">4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。</span><br />
<span style="word-wrap:normal;word-break:normal;color:#333333;">以上1,2推荐；而3,4不提倡</span></span></span></div>
<div style="color:#7f7f7f;font-size:16px;line-height:28px;"><span style="word-wrap:normal;word-break:normal;line-height:24px;font-size:14px;"><span style="word-wrap:normal;word-break:normal;font-family:'Comic sans Ms';"><br />
</span></span></div>
<div style="color:#7f7f7f;font-size:16px;line-height:28px;"><span style="word-wrap:normal;word-break:normal;line-height:24px;font-size:14px;"><span style="word-wrap:normal;word-break:normal;font-family:'Comic sans Ms';">drawRect方法使用注意点：</span></span></div>
<p style="margin-top:0pt;margin-bottom:0pt;padding:0px;border:0px;list-style:none;word-wrap:normal;word-break:normal;line-height:28px;color:#7f7f7f;font-size:16px;">&nbsp;<wbr></p>
<div style="color:#7f7f7f;font-size:16px;line-height:28px;"><span style="word-wrap:normal;word-break:normal;line-height:24px;font-size:14px;"><span style="word-wrap:normal;word-break:normal;font-family:'Comic sans Ms';"><span style="word-wrap:normal;word-break:normal;color:#333333;">1、 若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate 的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay&nbsp;<wbr>或 者&nbsp;<wbr>setNeedsDisplayInRect，让系统自动调该方法。</span><br />
<span style="word-wrap:normal;word-break:normal;color:#333333;">2、若使用calayer绘图，只能在drawInContext:&nbsp;<wbr>中（类似鱼drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法</span><br />
<span style="word-wrap:normal;word-break:normal;color:#333333;">3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕</span></span></span></div>
</div>
</div>
</div>
</div></body></html>