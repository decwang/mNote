<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content=mNote Mac 2.5.11"/><meta name="created" content="2016-09-28T10:44:47Z"/><meta name="updated" content="2016-10-08T09:05:23Z"/><title> iOS开发--事件处理之响应链（二）    标签： ios  2016-06-08 16:42 215人阅读 评论(1) 收藏 举报     分类：  iOS（62）       目录(?)[+]</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div class="article_title" style="margin:5px 0px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;font-size:20px;line-height:30px;font-family:'Microsoft YaHei';widows:1;">&nbsp;<h1 style="margin:0px;padding:0px;display:inline;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;font-weight:normal;font-size:20px;line-height:30px;vertical-align:middle;"><span class="link_title"><a href="http://blog.csdn.net/hanrovey/article/details/51614201" style="color:#000000;text-decoration:none;">iOS开发--事件处理之响应链（二）</a></span></h1>
</div>
<div class="article_manage clearfix" style="padding:0px 20px 5px;color:#999999;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;font-size:12px;line-height:22px;font-family:Arial;text-align:right;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:#ededed;margin:0px -20px;overflow:hidden;widows:1;"><div class="article_l" style="width:946px;float:left;"><span class="link_categories" style="margin:0px 5px;float:left;">标签：&nbsp;<a href="http://www.csdn.net/tag/ios" target="_blank" style="color:#ca0000;text-decoration:none;display:inline-block;margin-right:10px;">ios</a></span></div>
<div class="article_r"><span class="link_postdate" style="margin:0px 5px 0px 0px;">2016-06-08 16:42</span>&nbsp;<span class="link_view" title="阅读次数" style="margin:0px 5px;padding:0px 0px 0px 14px;background:url(http://static.blog.csdn.net/images/ico_view.png) 0% 50% no-repeat;">215人阅读</span>&nbsp;<span class="link_comments" title="评论次数" style="margin:0px 5px;padding:0px 0px 0px 14px;background:url(http://static.blog.csdn.net/images/ico_comm.png) 0% 50% no-repeat;"><a href="http://blog.csdn.net/Hanrovey/article/details/51614201#comments" style="color:#ca0000;text-decoration:none;">评论</a>(1)</span>&nbsp;<span class="link_collect tracking-ad" data-mod="popu_171" style="margin:0px 5px;"><a title="收藏" target="_blank" style="color:#ca0000;">收藏</a></span>&nbsp;<span class="link_report" style="margin:0px 5px;"><a href="http://blog.csdn.net/Hanrovey/article/details/51614201#report" title="举报" style="color:#ca0000;text-decoration:none;">举报</a></span></div>
</div>
<div class="category clearfix" style="margin:0px -20px;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:#ededed;padding:5px 20px;font-family:Arial, Console, Verdana, 'Courier New';font-size:12px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:normal;widows:1;"><div class="category_l" style="display:inline-block;font-size:14px;color:#333333;width:70px;float:left;line-height:28px;"><img src="http://static.blog.csdn.net/images/category_icon.jpg" style="border:none;vertical-align:middle;" />&nbsp;<span style="display:inline-block;vertical-align:middle;">分类：</span></div>
<div class="category_r" style="display:inline-block;font-size:14px;color:#df3434;float:left;width:851.391px;"><label style="display:inline-block;margin-left:15px;cursor:pointer;line-height:28px;position:relative;">iOS（62）&nbsp;<img class="arrow-down" src="http://static.blog.csdn.net/images/arrow_triangle%20_down.jpg" style="border:none;display:inline;" /></label></div>
</div>
<div style="font-family:Arial, Console, Verdana, 'Courier New';font-size:12px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:normal;widows:1;clear:both;"></div>
<div style="font-family:Arial, Console, Verdana, 'Courier New';font-size:12px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:normal;widows:1;border:1px solid #cccccc;float:left;min-width:200px;padding:4px 10px;background-color:#eeeeee;background-position:initial initial;background-repeat:initial initial;"><p style="margin-top:0px;margin-bottom:0px;padding:0px;text-align:right;"><span style="float:left;">目录<a href="http://blog.csdn.net/Hanrovey/article/details/51614201#" title="系统根据文章中H1到H6标签自动生成文章目录" style="color:#ca0000;text-decoration:none;">(?)</a></span><a href="http://blog.csdn.net/Hanrovey/article/details/51614201#" title="展开" style="color:#ca0000;text-decoration:none;">[+]</a></p>
</div>
<div style="font-family:Arial, Console, Verdana, 'Courier New';font-size:12px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:normal;widows:1;clear:both;"></div>
<div id="article_content" class="article_content" style="margin:20px 0px 0px;font-variant-ligatures:normal;font-variant-position:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;line-height:26px;font-family:Arial;widows:1;"><div class="markdown_views" style="font-family:'microsoft yahei';"><h3 id="事件传递响应链" style="margin:0.8em 0px;padding:0px;box-sizing:border-box;font-weight:100;"><a name="t0" style="color:#ca0000;box-sizing:border-box;"></a>事件传递：响应链</h3>
<h5 id="当你设计你的应用程序很可能想要得到事件的动态响应例如可能会出现一个触摸有多个对象响应因此你必须要决定是哪个对象要响应和处理此触摸事件" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;"><a name="t1" style="color:#ca0000;box-sizing:border-box;"></a>当你设计你的应用程序，很可能想要得到事件的动态响应。例如，可能会出现一个触摸，有多个对象响应，因此你必须要决定是哪个对象要响应和处理此触摸事件。</h5>
<h5 id="当用户生成的事件发生时uikit中创建包含处理该事件所需要的信息的事件对象然后它会在事件对象主动应用程序的事件队列为触摸事件时该对象是一组包装在触摸的uievent对象对于运动事件该事件对象取决于您所使用的框架和什么类型的运动事件是你感兴趣的内容" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;">当用户生成的事件发生时，UIKit中创建包含处理该事件所需要的信息的事件对象。然后，它会在事件对象主动应用程序的事件队列。为触摸事件时，该对象是一组包装在触摸的UIEvent对象。对于运动事件，该事件对象取决于您所使用的框架和什么类型的运动事件是你感兴趣的内容。</h5>
<h5 id="该事件会沿着特定路径传递直到它被输送到一个可以处理它的对象首先单例uiapplication对象从队列的顶部发生的事件并分派它用于处理通常情况下它发送事件到应用程序的key-window-object主窗口对象由它来进行处理初始对象初始对象取决于事件类型" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;">该事件会沿着特定路径传递，直到它被输送到一个可以处理它的对象。首先，单例<strong style="box-sizing:border-box;">UIApplication</strong>对象从队列的顶部发生的事件并分派它用于处理。通常情况下，它发送事件到应用程序的<strong style="box-sizing:border-box;">key window object</strong>(主窗口对象)，由它来进行处理初始对象。初始对象取决于事件类型。</h5>
<h5 id="1touch-events对于触摸事件窗口对象首先尝试将事件交给触摸发生时的视图这一视图被称为hit-test视图找到hit-test视图的过程被称为hit-testing详细参考官方文档" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;"><a name="t4" style="color:#ca0000;box-sizing:border-box;"></a><strong style="box-sizing:border-box;">1.Touch events</strong>。对于触摸事件，窗口对象首先尝试将事件交给触摸发生时的视图。这一视图被称为hit-test视图。找到hit-test视图的过程被称为<strong style="box-sizing:border-box;">hit-testing</strong>，<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW4" style="color:#ca0000;text-decoration:none;box-sizing:border-box;">详细参考官方文档</a>。</h5>
<h5 id="2motion-and-remote-control-events-对于这些事件窗口对象发送摇动动作或远程遥控事件给能进行处理这些事件的第一个响应者查看第一响应者具体信息请参考官方文档" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;"><a name="t5" style="color:#ca0000;box-sizing:border-box;"></a><strong style="box-sizing:border-box;">2.Motion and remote control events</strong>。 对于这些事件，窗口对象发送摇动动作或远程遥控事件给能进行处理这些事件的第一个响应者。查看第一响应者具体信息，<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1" style="color:#ca0000;text-decoration:none;box-sizing:border-box;">请参考官方文档</a>。</h5>
<h5 id="这些事件的路径的最终目标是要找到一个对象该对象能够处理和对事件作出响应因此uikit中首先发送事件到最适于处理该事件的对象对于触摸事件这个对象是hit-test视图对于其他事件该对象是第一个响应者下面的章节详细介绍hit-test视图和第一响应者对象" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;">这些事件的路径的最终目标是要找到一个对象，该对象能够处理和对事件作出响应。因此，UIKit中首先发送事件到最适于处理该事件的对象。对于触摸事件，这个对象是hit-test视图，对于其他事件，该对象是第一个响应者。下面的章节详细介绍<strong style="box-sizing:border-box;">hit-test视图</strong>和<strong style="box-sizing:border-box;">第一响应者对象</strong>。</h5>
<hr style="box-sizing:border-box;margin:2em 0px;border-right-width:0px;border-bottom-width:0px;border-left-width:0px;border-top-style:solid;border-top-color:rgba(128, 128, 128, 0.0980392);" />
<h3 id="视图的某一个地方发生触摸返回一个hit-testing" style="margin:0.8em 0px;padding:0px;box-sizing:border-box;font-weight:100;"><a name="t7" style="color:#ca0000;box-sizing:border-box;"></a>视图的某一个地方发生触摸返回一个Hit-Testing</h3>
<h5 id="ios的使用hit-testing来确认某个视图是否被触摸hit-testing包括检查触摸是否发生在任何相关视图对象的范围之内如果是它递归地检查所有视图的子视图在包含触摸点视图层次最低的视图成为hit-test视图ios的确认hit-test视图后它会传递触摸事件到该视图进行处理" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;">iOS的使用<strong style="box-sizing:border-box;">hit-testing</strong>来确认某个视图是否被触摸。<strong style="box-sizing:border-box;">Hit-testing</strong>包括检查触摸是否发生在任何相关视图对象的范围之内。如果是，它递归地检查所有视图的子视图。在包含触摸点视图层次最低的视图成为hit-test视图。iOS的确认hit-test视图后，它会传递触摸事件到该视图进行处理。</h5>
<h5 id="举例说明如图2-1假设用户触摸view-eios通过hit-test视图通过以下步骤在子视图中进行查找" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;"><a name="t9" style="color:#ca0000;box-sizing:border-box;"></a>举例说明，如图2-1假设用户触摸view E。iOS通过hit-test视图通过以下步骤在子视图中进行查找：</h5>
<h5 id="1-触摸是位于a的范围内因此会检查子视图b和c" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;"><a name="t10" style="color:#ca0000;box-sizing:border-box;"></a>1. 触摸是位于A的范围内，因此会检查子视图B和C.</h5>
<h5 id="2-触摸不在视图b的范围内但在视图c的范围内因此它检查子视图d和e" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;"><a name="t11" style="color:#ca0000;box-sizing:border-box;"></a>2. 触摸不在视图B的范围内，但在视图C的范围内，因此，它检查子视图D和E</h5>
<h5 id="3-触摸不在视图d的范围内但它在图e的范围内" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;"><a name="t12" style="color:#ca0000;box-sizing:border-box;"></a>3. 触摸不在视图D的范围内，但它在图E的范围内，</h5>
<h5 id="视图e是在包含触摸视图以内层次最低的视图因此它成为hit-test视图" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;"><a name="t13" style="color:#ca0000;box-sizing:border-box;"></a>视图E是在包含触摸视图以内，层次最低的视图，因此它成为hit-test视图。</h5>
<p style="margin-top:0px;margin-bottom:1.1em;padding:0px;box-sizing:border-box;"><img src="http://img.blog.csdn.net/20160608163326468" alt="这里写图片描述" title="" style="border:none;box-sizing:border-box;" />&nbsp;<br style="box-sizing:border-box;" />
图2-1 Hit-testing视图：子视图中被点击的视图</p>
<h5 id="该hittestwithevent方法返回一个给定的点击测试视图的cgpoint和uievent该hittestwithevent方法首先调用pointinsidewithevent方法本身的方法如果点传递到hittestwithevent方法认为该点击在某个视图的边界内则pointinsidewithevent方法返回yes然后该方法递归地调用hittestwithevent方法对每一个子视图返回yes" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;">该<strong style="box-sizing:border-box;">hitTest：withEvent：</strong>方法返回一个给定的点击测试视图的<strong style="box-sizing:border-box;">CGPoint</strong>和<strong style="box-sizing:border-box;">UIEvent</strong>。该<strong style="box-sizing:border-box;">hitTest：withEvent：</strong>方法首先调用<strong style="box-sizing:border-box;">pointInside：withEvent：</strong>方法本身的方法。如果点传递到<strong style="box-sizing:border-box;">hitTest：withEvent：</strong>方法认为该点击在某个视图的边界内，则<strong style="box-sizing:border-box;">pointInside：withEvent：</strong>方法返回<strong style="box-sizing:border-box;">YES</strong>。然后，该方法递归地调用<strong style="box-sizing:border-box;">hitTest：withEvent：</strong>方法对每一个子视图返回<strong style="box-sizing:border-box;">YES</strong>。</h5>
<h5 id="如果点传递到hittestwithevent方法而不在视图的边界内以第一次调用pointinsidewithevent方法返回no该点被忽略则hittestwithevent方法返回无如果一个子视图返回no则该视图的全部子视图都将停止传递如果子视图的可能出现这种情况这种情况指该视图通过调用pointinsidewithevent方法返回no则clipstobounds属性设置为no" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;">如果点传递到<strong style="box-sizing:border-box;">hitTest：withEvent：</strong>方法而不在视图的边界内，以第一次调用<strong style="box-sizing:border-box;">pointInside：withEvent：</strong>方法返回<strong style="box-sizing:border-box;">NO</strong>，该点被忽略，则<strong style="box-sizing:border-box;">hitTest：withEvent：</strong>方法返回无。如果一个子视图返回NO，则该视图的全部子视图都将停止传递。如果子视图的可能出现这种情况(这种情况指：该视图通过调用<strong style="box-sizing:border-box;">pointInside：withEvent：</strong>方法，返回NO)，则<strong style="box-sizing:border-box;">clipsToBounds</strong>属性设置为NO。</h5>
<blockquote style="box-sizing:border-box;margin:0px 0px 1.1em;padding:15px 20px;border-left-width:10px;border-left-style:solid;border-left-color:rgba(128, 128, 128, 0.0745098);border-radius:0px 5px 5px 0px;background-color:rgba(128, 128, 128, 0.0470588);"><p style="margin-top:0px;margin-bottom:0px;padding:0px;box-sizing:border-box;line-height:1.25;">注： 触摸对象的生命周期与它的hit-test视图相关联，即使触摸比较晚才离开视图。</p>
</blockquote>
<hr style="box-sizing:border-box;margin:2em 0px;border-right-width:0px;border-bottom-width:0px;border-left-width:0px;border-top-style:solid;border-top-color:rgba(128, 128, 128, 0.0980392);" />
<h3 id="响应链是由响应对象组成" style="margin:0.8em 0px;padding:0px;box-sizing:border-box;font-weight:100;"><a name="t16" style="color:#ca0000;box-sizing:border-box;"></a>响应链是由响应对象组成</h3>
<h5 id="多种类型的事件依赖于一个响应链的事件传递响应链是一系列响应对象之间的相互链接响应链开始于第一响应者结束于应用对象如果第一响应者不能处理事件时它转发该事件到响应链中的下一个响应者" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;"><a name="t17" style="color:#ca0000;box-sizing:border-box;"></a>多种类型的事件依赖于一个响应链的事件传递。响应链是一系列响应对象之间的相互链接。响应链开始于第一响应者，结束于应用对象。如果第一响应者不能处理事件时，它转发该事件到响应链中的下一个响应者。</h5>
<h5 id="一个响应者对象是一个对象可以响应和处理事件uiresponder类是所有响应者对象的基类它定义编程接口不仅可以处理事件也可以响应常见的响应者行为例如uiapplicationuiviewcontroller和uiview这些类是响应者这意味着所有的view和大部分的controller是响应者需要注意的是core-animation-layers核心动画层不能成为响应者" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;">一个响应者对象是一个对象，可以响应和处理事件。<strong style="box-sizing:border-box;">UIResponder</strong>类是所有响应者对象的基类，它定义编程接口不仅可以处理事件也可以响应常见的响应者行为。例如：<strong style="box-sizing:border-box;">UIApplication</strong>，<strong style="box-sizing:border-box;">UIViewController</strong>和<strong style="box-sizing:border-box;">UIView</strong>这些类是响应者，这意味着所有的View和大部分的Controller是响应者。需要注意的是Core Animation layers（核心动画层）不能成为响应者。</h5>
<blockquote style="box-sizing:border-box;margin:0px 0px 1.1em;padding:15px 20px;border-left-width:10px;border-left-style:solid;border-left-color:rgba(128, 128, 128, 0.0745098);border-radius:0px 5px 5px 0px;background-color:rgba(128, 128, 128, 0.0470588);"><p style="margin-top:0px;margin-bottom:0px;padding:0px;box-sizing:border-box;line-height:1.25;">注意：Layer 不能成为响应者，View和Controller能成为响应者。</p>
</blockquote>
<h5 id="第一响应者默认被指定为第一个接收事件的对象通常情况下第一响应者是一个view视图对象一个对象要成为第一响应者要完成以下两条件" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;"><a name="t19" style="color:#ca0000;box-sizing:border-box;"></a>第一响应者默认被指定为第一个接收事件的对象。通常情况下，第一响应者是一个View（视图）对象。一个对象要成为第一响应者要完成以下两条件：</h5>
<h5 id="1-重写canbecomefirstresponder方法返回yes" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;"><a name="t20" style="color:#ca0000;box-sizing:border-box;"></a>1 .重写<strong style="box-sizing:border-box;">canBecomeFirstResponder</strong>方法，返回<strong style="box-sizing:border-box;">YES</strong>。</h5>
<h5 id="2-接收becomefirstresponder消息如果有必要一个对象可以自行发送此消息" style="box-sizing:border-box;font-weight:100;margin:0.8em 0px;"><a name="t21" style="color:#ca0000;box-sizing:border-box;"></a>2. 接收<strong style="box-sizing:border-box;">becomeFirstResponder</strong>消息。如果有必要，一个对象可以自行发送此消息。</h5>
<blockquote style="box-sizing:border-box;margin:0px 0px 1.1em;padding:15px 20px;border-left-width:10px;border-left-style:solid;border-left-color:rgba(128, 128, 128, 0.0745098);border-radius:0px 5px 5px 0px;background-color:rgba(128, 128, 128, 0.0470588);"><p style="margin-top:0px;margin-bottom:0px;padding:0px;box-sizing:border-box;line-height:1.25;">注： 一个对象要想成为第一个响应者，必须保证该对象已经被创建。例如，您通常在<strong style="box-sizing:border-box;">viewDidAppear：</strong>方法中调用<strong style="box-sizing:border-box;">becomeFirstResponder</strong>。如果您尝试在<strong style="box-sizing:border-box;">viewWillAppear：</strong>的时候，分配第一个响应者，则<strong style="box-sizing:border-box;">becomeFirstResponder</strong>方法返回NO，因为此时对象还没被创建。</p>
</blockquote>
<p style="margin-top:0px;margin-bottom:1.1em;padding:0px;box-sizing:border-box;"><strong style="box-sizing:border-box;">Events(事件)</strong>不是依赖于响应链的唯一对象。响应者链在以下所有情况中也使用：</p>
<ol style="box-sizing:border-box;"><li style="box-sizing:border-box;"><strong style="box-sizing:border-box;">Touch events(触摸事件)</strong>。如果hit-test视图无法处理触摸事件。则该事件从hit-test视图开始，在响应者链中终止传递。</li>
<li style="box-sizing:border-box;"><strong style="box-sizing:border-box;">Motion events(运动事件)</strong>。UIKit中的摇一摇动作，第一响应者必须实现UIResponder类中的<strong style="box-sizing:border-box;">motionBegan：withEvent：</strong>方法或<strong style="box-sizing:border-box;">motionEnded：withEvent：</strong>方法，正如<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW2" style="color:#ca0000;text-decoration:none;box-sizing:border-box;">Detecting Shake-Motion Events with UIEvent</a>&nbsp;文档中所描述的。</li>
<li style="box-sizing:border-box;"><strong style="box-sizing:border-box;">Remote control events(远程遥控事件)</strong>。处理远程遥控事件，第一个响应者必须实现UIResponder类中的<strong style="box-sizing:border-box;">remoteControlReceivedWithEvent：</strong>方法。</li>
<li style="box-sizing:border-box;"><strong style="box-sizing:border-box;">Action messages(动作信息)</strong>。当用户操纵一个控件时，例如<strong style="box-sizing:border-box;">UIButton</strong>或<strong style="box-sizing:border-box;">UISwitch</strong>，如果这些控件不存在响应方法，该消息将由第一个响应者通过响应者链，传递到具体能响应该事件的控件上。</li>
<li style="box-sizing:border-box;"><strong style="box-sizing:border-box;">Editing-menu messages(编辑菜单消息)</strong>。当用户点击编辑菜单中的命令，iOS采用了响应者链找到实现该方法的对象（如剪切，复制，粘贴）。欲了解更多信息，请参阅&nbsp;<a href="https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/AddingCustomEditMenuItems/AddingCustomEditMenuItems.html#//apple_ref/doc/uid/TP40009542-CH13" style="color:#ca0000;text-decoration:none;box-sizing:border-box;">Displaying and Managing the Edit Menu</a>，CopyPasteTile（剪切板）。</li>
<li style="box-sizing:border-box;"><strong style="box-sizing:border-box;">Text editing(文本编辑)</strong>。当用户点击文本字段或文本视图，该视图自动成为第一个响应者。默认情况下，虚拟键盘和显示文本字段或文本视图编辑成为关注的焦点。如果它是适合您的应用程序，你可以显示一个定制输入视图，而不是键盘。您还可以添加自定义输入，以便作出响应的对象。欲了解更多信息，请参阅&nbsp;<a href="https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12" style="color:#ca0000;text-decoration:none;box-sizing:border-box;">Custom Views for Data Input</a>。</li>
</ol>
<blockquote style="box-sizing:border-box;margin:0px 0px 1.1em;padding:15px 20px;border-left-width:10px;border-left-style:solid;border-left-color:rgba(128, 128, 128, 0.0745098);border-radius:0px 5px 5px 0px;background-color:rgba(128, 128, 128, 0.0470588);"><p style="margin-top:0px;margin-bottom:0px;padding:0px;box-sizing:border-box;line-height:1.25;">注: UIKit中自动设置文本字段或文本观点，即用户点击成为第一个响应者; 应用程序必须显式设置与所有其他第一响应者对象becomeFirstResponder方法。</p>
</blockquote>
<h3 id="响应链按照特定的传送路径" style="margin:0.8em 0px;padding:0px;box-sizing:border-box;font-weight:100;"><a name="t22" style="color:#ca0000;box-sizing:border-box;"></a>响应链按照特定的传送路径</h3>
<p style="margin-top:0px;margin-bottom:1.1em;padding:0px;box-sizing:border-box;">如果初始对象或者hit-test视图或第一响应者不能处理一个事件，UIKit将通过响应链中<strong style="box-sizing:border-box;">nextResponder</strong>来传递该事件。各应答器决定是否自己处理该事件或通过调用其传递给它自己的下一个应答器的<strong style="box-sizing:border-box;">nextResponder&nbsp;</strong>方法来继续传递，这个过程直到一个响应者对象终止处理事件或已经没有更多的响应者而结束。</p>
<p style="margin-top:0px;margin-bottom:1.1em;padding:0px;box-sizing:border-box;">当iOS检测到事件并将其传递到初始对象，该视图响应链按顺序开始进行。初始视图可以第一次处理该事件。图2-2显示了两个应用程序配置两个不同的事件传递路径。一个应用程序的事件传递路径取决于它的具体结构，但所有事件传递路径，采用相同的启发法。</p>
<p style="margin-top:0px;margin-bottom:1.1em;padding:0px;box-sizing:border-box;"><img src="http://img.blog.csdn.net/20160608163344390" alt="这里写图片描述" title="" style="border:none;box-sizing:border-box;" /><br style="box-sizing:border-box;" />
图2-2 iOS上的响应链</p>
<p style="margin-top:0px;margin-bottom:1.1em;padding:0px;box-sizing:border-box;">左边的应用程序，该事件遵循此路径：</p>
<ol style="box-sizing:border-box;"><li style="box-sizing:border-box;">初始视图试图处理该事件或消息。如果它不能处理这个事件，它传递事件到SuperView，因为初始视图是它的视图控制器的视图层次最顶部的视图。</li>
<li style="box-sizing:border-box;">SuperView尝试处理该事件。如果SuperView不能处理这个事件，它传递该事件到它的SuperView，因为它仍然不是视图层次最顶部的视图。</li>
<li style="box-sizing:border-box;">视图控制器中最上层的视图尝试处理该事件。如果最上层的视图不能处理这个事件，它传递该事件到它的视图控制器。</li>
<li style="box-sizing:border-box;">视图控制器试图处理该事件，如果不能，将事件传递到窗口。</li>
<li style="box-sizing:border-box;">如果窗口对象不能处理这个事件，它传递事件到<strong style="box-sizing:border-box;">Application</strong>。</li>
<li style="box-sizing:border-box;">如果Application对象不能处理这个事件，它丢弃该事件。</li>
</ol>
<p style="margin-top:0px;margin-bottom:1.1em;padding:0px;box-sizing:border-box;">右边的应用程序遵循稍有不同的路径，但所有事件传递路径，请按照下列路径：</p>
<ol style="box-sizing:border-box;"><li style="box-sizing:border-box;">初始视图传递事件，直到该事件到达它的视图控制器的视图层次最顶端的视图。</li>
<li style="box-sizing:border-box;">最顶端的视图传递事件到其视图控制器。</li>
<li style="box-sizing:border-box;">视图控制器将事件传递到其最上面的视图的。步骤1-3重复，直到事件到达根视图控制器。 </li>
<li style="box-sizing:border-box;">根视图控制器传递事件到窗口对象。</li>
<li style="box-sizing:border-box;">窗口对象传递事件到应用程序对象。</li>
</ol>
<blockquote style="box-sizing:border-box;margin:0px 0px 1.1em;padding:15px 20px;border-left-width:10px;border-left-style:solid;border-left-color:rgba(128, 128, 128, 0.0745098);border-radius:0px 5px 5px 0px;background-color:rgba(128, 128, 128, 0.0470588);"><p style="margin-top:0px;margin-bottom:0px;padding:0px;box-sizing:border-box;line-height:1.25;">重要提示： 如果您实现一个自定义视图来处理远程遥控事件，行动的消息，摇一摇事件，或编辑菜单中的邮件，不转发事件或消息通过nextResponder直接把它送到响应链中。相反，调用超类实现当前事件的处理方法，通过UIKit处理响应链方式，方便的为您服务。</p>
</blockquote>
</div>
</div></body></html>