<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content=mNote Mac 2.5.11"/><meta name="created" content="2017-05-15T02:57:35Z"/><meta name="updated" content="2017-05-15T02:57:41Z"/><title>各种排序算法的时间复杂度</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><h1 class="postTitle" style="margin:0px;padding:0px 100px 10px 5px;font-size:15.6px;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#999999;line-height:1.5em;clear:both;border-left-width:5px;border-left-style:solid;border-left-color:#1fa6e6;font-family:Verdana, Arial, Helvetica, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><br />
</h1>
<div class="clear" style="margin:0px;padding:0px;clear:both;font-family:Verdana, Arial, Helvetica, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;"></div>
<div class="postBody" style="margin:0px;padding:5px 2px 5px 5px;line-height:1.8;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:#000000;font-family:Verdana, Arial, Helvetica, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;"><div id="cnblogs_post_body" style="margin:0px 0px 20px;padding:0px;word-break:break-word;"><p style="margin:10px auto;padding:0px;"><img src="http://images2015.cnblogs.com/blog/967841/201611/967841-20161117232357404-1396510310.png" alt="" style="margin:0px;padding:0px;border:0px;max-width:660px;" /></p>
<p style="margin:10px auto;padding:0px;"><strong style="margin:0px;padding:0px;">1.快速排序（QuickSort）</strong><br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
快速排序是一个就地排序，分而治之，大规模递归的<a class="replace_word" title="算法与数据结构知识库" href="http://lib.csdn.net/base/datastructure" target="_blank" style="margin:0px;padding:0px;color:#000000;">算法</a>。从本质上来说，它是归并排序的就地版本。快速排序可以由下面四步组成。<br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
（1）&nbsp;如果不多于1个数据，直接返回。<br style="margin:0px;padding:0px;" />
（2）&nbsp;一般选择序列最左边的值作为支点数据。<br style="margin:0px;padding:0px;" />
（3）&nbsp;将序列分成2部分，一部分都大于支点数据，另外一部分都小于支点数据。<br style="margin:0px;padding:0px;" />
（4）&nbsp;对两边利用递归排序数列。<br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
快速排序比大部分排序算法都要快。尽管我们可以在某些特殊的情况下写出比快速排序快的算法，但是就通常情况而言，没有比它更快的了。快速排序是递归的，对于内存非常有限的机器来说，它不是一个好的选择。&nbsp;<br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
<strong style="margin:0px;padding:0px;">2.归并排序（MergeSort）</strong><br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
归并排序先分解要排序的序列，从1分成2，2分成4，依次分解，当分解到只有1个一组的时候，就可以排序这些分组，然后依次合并回原来的序列中，这样就可以排序所有数据。合并排序比堆排序稍微快一点，但是需要比堆排序多一倍的内存空间，因为它需要一个额外的数组。<br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
<strong style="margin:0px;padding:0px;">3.堆排序（HeapSort）</strong><br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
堆排序适合于数据量非常大的场合（百万数据）。<br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
堆排序不需要大量的递归或者多维的暂存数组。这对于数据量非常巨大的序列是合适的。比如超过数百万条记录，因为快速排序，归并排序都使用递归来设计算法，在数据量非常大的时候，可能会发生堆栈溢出错误。<br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
堆排序会将所有的数据建成一个堆，最大的数据在堆顶，然后将堆顶数据和序列的最后一个数据交换。接下来再次重建堆，交换数据，依次下去，就可以排序所有的数据。<br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
<strong style="margin:0px;padding:0px;">4.Shell排序（ShellSort）<br style="margin:0px;padding:0px;" />
</strong><br style="margin:0px;padding:0px;" />
Shell排序通过将数据分成不同的组，先对每一组进行排序，然后再对所有的元素进行一次插入排序，以减少数据交换和移动的次数。平均效率是O(nlogn)。其中分组的合理性会对算法产生重要的影响。现在多用D.E.Knuth的分组方法。<br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
Shell排序比冒泡排序快5倍，比插入排序大致快2倍。Shell排序比起QuickSort，MergeSort，HeapSort慢很多。但是它相对比较简单，它适合于数据量在5000以下并且速度并不是特别重要的场合。它对于数据量较小的数列重复排序是非常好的。<br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
<strong style="margin:0px;padding:0px;">5.插入排序（InsertSort）</strong><br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
插入排序通过把序列中的值插入一个已经排序好的序列中，直到该序列的结束。插入排序是对冒泡排序的改进。它比冒泡排序快2倍。一般不用在数据大于1000的场合下使用插入排序，或者重复排序超过200数据项的序列。<br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
<strong style="margin:0px;padding:0px;">6.冒泡排序（BubbleSort）</strong><br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
冒泡排序是最慢的排序算法。在实际运用中它是效率最低的算法。它通过一趟又一趟地比较数组中的每一个元素，使较大的数据下沉，较小的数据上升。它是O(n^2)的算法。<br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
<strong style="margin:0px;padding:0px;">7.交换排序（ExchangeSort）和选择排序（SelectSort）</strong><br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
这两种排序方法都是交换方法的排序算法，效率都是&nbsp;O(n<sup style="margin:0px;padding:0px;">2</sup>)。在实际应用中处于和冒泡排序基本相同的地位。它们只是排序算法发展的初级阶段，在实际中使用较少。<br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
<strong style="margin:0px;padding:0px;">8.基数排序（RadixSort）</strong><br style="margin:0px;padding:0px;" />
<br style="margin:0px;padding:0px;" />
基数排序和通常的排序算法并不走同样的路线。它是一种比较新颖的算法，但是它只能用于整数的排序，如果我们要把同样的办法运用到浮点数上，我们必须了解浮点数的存储格式，并通过特殊的方式将浮点数映射到整数上，然后再映射回去，这是非常麻烦的事情，因此，它的使用同样也不多。而且，最重要的是，这样算法也需要较多的存储空间。</p>
<p style="margin:10px auto;padding:0px;">参考：<a href="http://blog.csdn.net/likefrank/article/details/2974949" target="_blank" style="margin:0px;padding:0px;color:#000000;">http://blog.csdn.net/likefrank/article/details/2974949</a></p>
</div>
</div></body></html>