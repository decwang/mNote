<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content=mNote Mac 2.5.11"/><meta name="created" content="2017-06-07T06:41:52Z"/><meta name="updated" content="2017-06-07T06:41:59Z"/><title>LSM树由来、设计思想以及应用到HBase的索引</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><h1 class="postTitle" style="margin:0px;padding:0px;font-size:1.5em;line-height:1.5em;width:725px;clear:both;text-align:center;"><br />
</h1>
<div class="clear" style="margin:0px;padding:0px;clear:both;"></div>
<div class="postBody" style="margin:0px;padding:5px;line-height:1.5;color:#444444;"><div id="cnblogs_post_body" style="margin:0px 0px 20px;padding:0px;word-break:break-word;"><p style="margin:10px auto;padding:0px;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;line-height:1.5 !important;">讲LSM树之前，需要提下三种基本的存储引擎，这样才能清楚<strong style="margin:0px;padding:0px;">LSM树的由来</strong>：</p>
<ul style="margin:0px 0px 0px 30px;padding:0px;word-break:break-all;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="margin:0px 0px 1em;padding:0px;list-style:disc;">哈希存储引擎 &nbsp;是哈希表的持久化实现，支持增、删、改以及随机读取操作，<strong style="margin:0px;padding:0px;">但不支持顺序扫描</strong>，对应的存储系统为key-value存储系统。对于key-value的插入以及查询，哈希表的复杂度都是O(1)，明显比树的操作O(n)快,如果不需要有序的遍历数据，哈希表就是your Mr.Right</li>
<li style="margin:0px 0px 1em;padding:0px;list-style:disc;">B树存储引擎是B树<a href="http://www.cnblogs.com/yanghuahui/p/3483047.html" target="_blank" style="margin:0px;padding:0px;color:#444444;">（关于B树的由来，数据结构以及应用场景可以看之前一篇博文）</a>的持久化实现，不仅支持单条记录的增、删、读、改操作，还支持顺序扫描（B+树的叶子节点之间的指针），对应的存储系统就是关系数据库（Mysql等）。</li>
<li style="margin:0px 0px 1em;padding:0px;list-style:disc;">LSM树（Log-Structured Merge Tree）存储引擎和B树存储引擎一样，同样支持增、删、读、改、顺序扫描操作。而且通过批量存储技术规避磁盘随机写入问题。<strong style="margin:0px;padding:0px;">当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。</strong></li>
</ul>
<p style="margin:10px auto;padding:0px;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;line-height:1.5 !important;">通过以上的分析，应该知道LSM树的由来了，LSM树的设计思想非常朴素：<strong style="margin:0px;padding:0px;">将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘</strong>，不过读取的时候稍微麻烦，需要合并磁盘中历史数据和内存中最近修改操作，所以写入性能大大提升，读取时可能需要先看是否命中内存，否则需要访问较多的磁盘文件。极端的说，基于LSM树实现的HBase的写性能比Mysql高了一个数量级，读性能低了一个数量级。</p>
<p style="margin:10px auto;padding:0px;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;line-height:1.5 !important;"><strong style="margin:0px;padding:0px;">LSM树原理把一棵大树拆分成N棵小树，它首先写入内存中，随着小树越来越大，内存中的小树会flush到磁盘中，磁盘中的树定期可以做merge操作，合并成一棵大树，以优化读性能。</strong></p>
<p style="margin:10px auto;padding:0px;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;line-height:1.5 !important;">&nbsp;</p>
<p style="margin:10px auto;padding:0px;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;line-height:1.5 !important;"><img src="http://images.cnitblog.com/blog/319578/201312/20135106-a1e5fd079a51484085065d3b29f2d331.png" alt="" style="margin:0px;padding:0px;border:0px;max-width:660px;" /></p>
<p style="margin:10px auto;padding:0px;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;line-height:1.5 !important;">以上这些大概就是HBase存储的设计主要思想，这里分别对应说明下：</p>
<ul style="margin:0px 0px 0px 30px;padding:0px;word-break:break-all;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;"><li style="margin:0px 0px 1em;padding:0px;list-style:disc;">因为小树先写到内存中，为了防止内存数据丢失，写内存的同时需要暂时持久化到磁盘，对应了HBase的MemStore和HLog</li>
<li style="margin:0px 0px 1em;padding:0px;list-style:disc;">MemStore上的树达到一定大小之后，需要flush到HRegion磁盘中（一般是Hadoop DataNode），这样MemStore就变成了DataNode上的磁盘文件StoreFile，定期HRegionServer对DataNode的数据做merge操作，彻底删除无效空间，多棵小树在这个时机合并成大树，来增强读性能。</li>
</ul>
<p style="margin:10px auto;padding:0px;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;line-height:1.5 !important;">&nbsp;</p>
<p style="margin:10px auto;padding:0px;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;line-height:1.5 !important;">关于LSM Tree，对于最简单的二层LSM Tree而言，内存中的数据和磁盘你中的数据merge操作，如下图</p>
<p style="margin:10px auto;padding:0px;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;line-height:1.5 !important;"><img src="http://images.cnitblog.com/blog/319578/201408/281219493293115.png" alt="" style="margin:0px;padding:0px;border:0px;max-width:660px;" /></p>
<p style="margin:10px auto;padding:0px;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;line-height:1.5 !important;">图来自<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.2782&amp;rep=rep1&amp;type=pdf" target="_blank" style="margin:0px;padding:0px;color:#444444;">lsm论文</a></p>
<p style="margin:10px auto;padding:0px;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;line-height:1.5 !important;">lsm tree，理论上，可以是内存中树的一部分和磁盘中第一层树做merge，对于磁盘中的树直接做update操作有可能会破坏物理block的连续性，但是实际应用中，一般lsm有多层，当磁盘中的小树合并成一个大树的时候，可以重新排好顺序，使得block连续，优化读性能。</p>
<p style="margin:10px auto;padding:0px;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;line-height:1.5 !important;">hbase在实现中，是把整个内存在一定阈值后，flush到disk中，形成一个file，这个file的存储也就是一个小的B+树，因为hbase一般是部署在hdfs上，hdfs不支持对文件的update操作，所以hbase这么整体内存flush，而不是和磁盘中的小树merge update，这个设计也就能讲通了。内存flush到磁盘上的小树，定期也会合并成一个大树。整体上hbase就是用了lsm tree的思路。</p>
<div><br />
</div>
</div>
</div></body></html>