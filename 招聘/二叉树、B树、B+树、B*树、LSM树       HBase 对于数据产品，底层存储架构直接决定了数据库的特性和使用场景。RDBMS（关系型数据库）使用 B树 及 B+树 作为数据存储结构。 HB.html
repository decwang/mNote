<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content=mNote Mac 2.5.11"/><meta name="created" content="2017-06-07T07:01:47Z"/><meta name="updated" content="2017-06-07T07:01:49Z"/><title>二叉树、B树、B+树、B*树、LSM树       HBase 对于数据产品，底层存储架构直接决定了数据库的特性和使用场景。RDBMS（关系型数据库）使用 B树 及 B+树 作为数据存储结构。 HB</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><h1 class="postTitle" style="margin:0px;padding:0px;position:relative;width:690px;border:none;font-family:微软雅黑;font-variant-ligatures:normal;orphans:2;widows:2;background-color:#f4ede3;"><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/rocky24/p/4798644.html" style="margin:0px;padding:0px;color:#6a6352;font-family:微软雅黑, 华文细黑, 黑体, Arial;font-size:18px;font-weight:normal;text-decoration:none;">二叉树、B树、B+树、B*树、LSM树</a></h1>
<div class="clear" style="margin:0px;padding:0px;background-color:#f4ede3;clear:both;font-family:微软雅黑;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;"></div>
<div class="postBody" style="margin:0px;padding:0px;background-color:#f4ede3;position:relative;width:690px;height:auto;border:none;color:#494949;font-family:Arial, Helvetica, sans-serif;line-height:1.6;font-variant-ligatures:normal;orphans:2;widows:2;"><div id="cnblogs_post_body" style="margin:0px 0px 20px;padding:0px;background-color:transparent;word-break:break-word;"><div style="margin:0px;padding:0px;background-color:transparent;"><span style="margin:0px;padding:0px;background-color:#ffffff;">&nbsp;</span></div>
<div style="margin:0px;padding:0px;background-color:transparent;">HBase 对于数据产品，底层存储架构直接决定了数据库的特性和使用场景。RDBMS（关系型数据库）使用 B树 及 B+树 作为数据存储结构。 HBase 使用 LSM树。 。</div>
<p style="margin:10px auto;padding:0px;"></p>
<div style="margin:0px;padding:0px;background-color:transparent;">&nbsp;</div>
<div style="margin:0px;padding:0px;background-color:transparent;">&nbsp;</div>
<div style="margin:0px;padding:0px;background-color:transparent;"><span style="margin:0px;padding:0px;"><strong style="margin:0px;padding:0px;">二叉树&nbsp;</strong></span></div>
<div style="margin:0px;padding:0px;background-color:transparent;"><span style="margin:0px;padding:0px;font-family:微软雅黑;font-size:10.5pt;line-height:1.5;">&nbsp; &nbsp;&nbsp;</span><span style="margin:0px;padding:0px;font-family:微软雅黑;font-size:10.5pt;line-height:1.5;">&nbsp; &nbsp;&nbsp;</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">所有节点至多拥有两个子节点。节点</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">B</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">树搜索，<span style="margin:0px;padding:0px;color:#0000ff;">从根结点开始</span>，如果查询的关键字与结点的<span style="margin:0px;padding:0px;color:#0000ff;">关键字相等，那么就命中</span>；</span></div>
<div style="margin:0px;padding:0px;background-color:transparent;"><span style="margin:0px;padding:0px;font-family:Arial;font-size:10.5pt;line-height:1.5;">&nbsp; &nbsp;&nbsp;</span><span style="margin:0px;padding:0px;font-family:Arial;font-size:10.5pt;line-height:1.5;">&nbsp; &nbsp;&nbsp;</span><img src="http://images2015.cnblogs.com/blog/723399/201509/723399-20150910173638434-1895498699.gif" alt="" name="" style="margin:0px;padding:0px;border:0px none;max-width:900px;font-size:10.5pt;font-family:Arial;line-height:26px;widows:1;" /></div>
<div style="margin:0px;padding:0px;background-color:transparent;"><p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;background-color:#ffffff;">&nbsp; &nbsp; &nbsp;</span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><strong style="margin:0px;padding:0px;font-size:10.5pt;color:#333333;font-family:宋体;line-height:28px;text-indent:28px;widows:1;text-align:center;">B+树</strong><br style="margin:0px;padding:0px;" />
</span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;font-family:宋体;">&nbsp; &nbsp;&nbsp;<span style="margin:0px;padding:0px;color:#ff0000;">数据的读取速度因素</span></span><strong style="margin:0px;padding:0px;font-size:10.5pt;color:#333333;font-family:宋体;line-height:28px;text-indent:28px;widows:1;text-align:center;"><br style="margin:0px;padding:0px;" />
</strong></span></p>
<p style="margin-top:10px;margin-bottom:10px;padding:0px;text-indent:28px;font-family:宋体;line-height:28px;widows:1;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;color:#333333;">由于传统的机械磁盘具有</span><span style="margin:0px;padding:0px;color:#0000ff;">快速顺序读写、慢速随机读写的访问特性，这个特性对磁盘存储结构和算法的选择影响甚大。</span></span></p>
<p style="margin-top:10px;margin-bottom:10px;padding:0px;text-indent:28px;color:#333333;font-family:宋体;line-height:28px;widows:1;"><span style="margin:0px;padding:0px;background-color:#ffffff;">为了改善数据访问特性，文件系统或数据库系统通常会对数据排序后存储，加快数据检索速度，这就需要保证数据在不断更新、插入、删除后依然有序，传统关系数据库的做法是使用B+树，如图所示。</span></p>
<p style="margin-top:10px;margin-bottom:10px;padding:0px;text-indent:28px;color:#333333;font-family:宋体;line-height:28px;widows:1;">&nbsp;</p>
<p style="margin-top:10px;margin-bottom:10px;padding:0px;text-indent:28px;color:#333333;font-family:宋体;line-height:28px;widows:1;"><span style="margin:0px;padding:0px;background-color:#ffffff;">&nbsp;</span></p>
<div style="margin:0px;padding:0px;background-color:transparent;font-family:Arial;line-height:26px;widows:1;"><span style="margin:0px;padding:0px;font-family:&quot;Microsoft Yahei&quot;, 华文黑体, Arail, Verdana, Helvetica, sans-serif;color:#454545;background-color:#ffffff;"><img src="http://images2015.cnblogs.com/blog/723399/201509/723399-20150910173638903-1853572566.gif" alt="" name="" style="margin:0px;padding:0px;border:0px none;max-width:900px;" /><br style="margin:0px;padding:0px;" />
</span></div>
<p style="margin-top:0px;margin-bottom:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;">&nbsp;</p>
<p style="margin-top:0px;margin-bottom:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;"><span style="margin:0px;padding:0px;background-color:#ffffff;">&nbsp;</span></p>
<p style="margin-top:0px;margin-bottom:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;"><span style="margin:0px;padding:0px;background-color:#ffffff;">B树在插入的时候，如果是最后一个node,那么速度非常快，因为是顺序写。</span></p>
<p style="margin-top:0px;margin-bottom:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;">&nbsp;</p>
<div style="margin:0px;padding:0px;background-color:transparent;font-family:Arial;line-height:26px;widows:1;"><span style="margin:0px;padding:0px;font-family:&quot;Microsoft Yahei&quot;, 华文黑体, Arail, Verdana, Helvetica, sans-serif;color:#454545;background-color:#ffffff;"><img src="http://images2015.cnblogs.com/blog/723399/201509/723399-20150910173639372-68353335.gif" alt="" name="" style="margin:0px;padding:0px;border:0px none;max-width:900px;" /><br style="margin:0px;padding:0px;" />
</span></div>
<p style="margin-top:0px;margin-bottom:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;">&nbsp;</p>
<p style="margin-top:0px;margin-bottom:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;"><span style="margin:0px;padding:0px;background-color:#ffffff;">&nbsp;</span></p>
<p style="margin-top:0px;margin-bottom:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;"><span style="margin:0px;padding:0px;background-color:#ffffff;">但如果有更新插入删除等综合写入，最后因为需要循环利用磁盘块，所以会出现较多的随机io.大量时间消耗在磁盘寻道时间上。</span></p>
<p style="margin-top:0px;margin-bottom:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;"><span style="margin:0px;padding:0px;background-color:#ffffff;">&nbsp;</span></p>
<div style="margin:0px;padding:0px;background-color:transparent;font-family:Arial;line-height:26px;widows:1;"><span style="margin:0px;padding:0px;font-family:&quot;Microsoft Yahei&quot;, 华文黑体, Arail, Verdana, Helvetica, sans-serif;color:#454545;background-color:#ffffff;"><img src="http://images2015.cnblogs.com/blog/723399/201509/723399-20150910173639700-1292192964.gif" alt="" name="" style="margin:0px;padding:0px;border:0px none;max-width:900px;" /><br style="margin:0px;padding:0px;" />
</span></div>
<p style="margin-top:0px;margin-bottom:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;">&nbsp;</p>
<p style="margin-top:0px;margin-bottom:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;"><span style="margin:0px;padding:0px;background-color:#ffffff;">&nbsp;</span></p>
<p style="margin-top:0px;margin-bottom:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;"><span style="margin:0px;padding:0px;background-color:#ffffff;">-----------------------------------------------------------------------------------------------------------------------------------</span></p>
<div style="margin:0px;padding:0px;background-color:transparent;"><span style="margin:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;font-size:10.5pt;background-color:#ffffff;">PS：B+树就是在B树基础上加两个规定 &nbsp;1.子结点只存指针，子结点存数据 &nbsp;2.所有子结点从左到右用双链表串起来</span></div>
<div style="margin:0px;padding:0px;background-color:transparent;"><p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;font-family:Arial;font-size:10.5pt;line-height:1.5;">&nbsp; &nbsp;&nbsp;</span><span style="margin:0px;padding:0px;font-family:Arial;line-height:25.9868px;widows:1;font-size:10.5pt;"><span style="margin:0px;padding:0px;color:#ff0000;">b+树</span></span><span style="margin:0px;padding:0px;font-family:Arial;font-size:10.5pt;line-height:26px;widows:1;"><span style="margin:0px;padding:0px;color:#ff0000;">原理</span>，b+树在查询过程中应该是不会慢的，但如果数据插入比较无序的时候，比如先插入5 然后10000然后3然后800 这样跨度很大的数据的时候，就需</span><span style="margin:0px;padding:0px;font-family:Arial;font-size:10.5pt;line-height:26px;widows:1;color:#0000ff;">要先“找到这个数据应该被插入的位置”，然后插入数据。</span><span style="margin:0px;padding:0px;font-family:Arial;font-size:10.5pt;line-height:26px;widows:1;">这个查找到位置的过程，如果非常离散，那么就意味着每次查找的时候，</span><span style="margin:0px;padding:0px;font-family:Arial;font-size:10.5pt;line-height:26px;widows:1;color:#0000ff;">他的子节点都不在内存中</span><span style="margin:0px;padding:0px;font-family:Arial;font-size:10.5pt;line-height:26px;widows:1;">，</span><span style="margin:0px;padding:0px;font-family:Arial;font-size:10.5pt;line-height:26px;widows:1;color:#0000ff;">这时候就必须使用磁盘寻道时间查找</span><span style="margin:0px;padding:0px;font-family:Arial;font-size:10.5pt;line-height:26px;widows:1;">。更新基本与插入是相同的</span></span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;font-size:10.5pt;background-color:#ffffff;">&nbsp;</span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><strong style="margin:0px;padding:0px;color:#333333;font-family:宋体;line-height:27.9934px;text-indent:28px;widows:1;text-align:center;">LSM树&nbsp;</strong><span style="margin:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;font-size:10.5pt;"><br style="margin:0px;padding:0px;" />
</span></span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><a href="http://s4.51cto.com/wyfs01/M01/30/81/wKioJlJYsuDiByBmAABe6I5EBcU053.jpg" target="_blank" style="margin:0px;padding:0px;color:#004276;font-family:宋体;font-size:10.5pt;line-height:28px;text-indent:28px;widows:1;"><img class="fit-image" src="http://images2015.cnblogs.com/blog/723399/201509/723399-20150910173640309-268325661.jpg" alt="" name="" width="781" height="318" border="0" style="margin:0px;padding:0px;border:0px;max-width:900px;text-align:center;width:690px;" /></a><br style="margin:0px;padding:0px;" />
</span></p>
</div>
<div style="margin:0px;padding:0px;background-color:transparent;"><p style="margin-top:0px;margin-bottom:0px;padding:0px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;font-family:微软雅黑;font-size:10.5pt;line-height:1.5;">&nbsp; &nbsp;&nbsp;</span>简单来说，就是放弃<span style="margin:0px;padding:0px;color:#0000ff;">磁盘读性能来换取写的顺序性</span>。<span style="margin:0px;padding:0px;line-height:26px;">乍一看，似乎会认为读应该是大部分系统最应该保证的特性，所以用读换写似乎不是个好买卖。但别急，听我分析之 &nbsp;<span style="margin:0px;padding:0px;color:#ff0000;">LSM树性能分析。</span></span></span></p>
</div>
</div>
<blockquote style="margin:0px 0px 0px 40px;padding:0px;background:none;border:none;"><div style="margin:0px;padding:0px;background-color:transparent;"><div style="margin:0px;padding:0px;background-color:transparent;"><p style="margin-top:0px;margin-bottom:0px;padding:0px;line-height:26px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;color:#0000ff;">1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存的速度超磁盘1000倍以上。</span>而<span style="margin:0px;padding:0px;color:#0000ff;">读取的性能提升</span>，主要还是依靠<span style="margin:0px;padding:0px;color:#0000ff;">内存命中率而非磁盘读的次数</span></span></p>
</div>
</div>
<div style="margin:0px;padding:0px;background-color:transparent;"><div style="margin:0px;padding:0px;background-color:transparent;"><p style="margin-top:0px;margin-bottom:0px;padding:0px;line-height:26px;"><span style="margin:0px;padding:0px;color:#0000ff;background-color:#ffffff;">2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写入不占用磁盘的io，读取就能获取更长时间的磁盘io使用权，从而也可以提升读取效率。</span></p>
</div>
</div>
</blockquote>
<div style="margin:0px;padding:0px;background-color:transparent;"><div style="margin:0px;padding:0px;background-color:transparent;"><p style="margin-top:0px;margin-bottom:0px;padding:0px;line-height:26px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;font-family:微软雅黑;font-size:10.5pt;line-height:1.5;">&nbsp; &nbsp; &nbsp;</span><span style="margin:0px;padding:0px;line-height:26px;">因此，虽然SSTable降低了了读的性能，但如果数据的<span style="margin:0px;padding:0px;color:#0000ff;">读取命中率有保障</span>的前提下，因为读取能够获得更多的磁盘io机会，<span style="margin:0px;padding:0px;color:#0000ff;">因此读取性能基本没有降低，甚至还会有提升。</span></span><span style="margin:0px;padding:0px;line-height:26px;"><span style="margin:0px;padding:0px;color:#0000ff;">而写入的性能则会获得较大幅度的提升</span>，基本上<span style="margin:0px;padding:0px;color:#0000ff;">是5~10倍左右。</span></span></span></p>
<p style="margin-top:0px;margin-bottom:0px;padding:0px;font-family:Arial;line-height:26px;widows:1;">&nbsp;</p>
<p style="margin-top:10px;margin-bottom:10px;padding:0px;text-indent:28px;font-family:宋体;line-height:28px;"><span style="margin:0px;padding:0px;color:#0000ff;font-size:10.5pt;background-color:#ffffff;">&nbsp;</span></p>
<p style="margin-top:10px;margin-bottom:10px;padding:0px;text-indent:28px;font-family:宋体;line-height:28px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;font-size:10.5pt;"><span style="margin:0px;padding:0px;color:#ff0000;">LSM树 插入数据</span></span><span style="margin:0px;padding:0px;font-size:10.5pt;">可以</span><span style="margin:0px;padding:0px;color:#333333;font-size:10.5pt;line-height:28px;">看作是一个N阶合并树。</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:28px;"><span style="margin:0px;padding:0px;color:#0000ff;">数据写操作</span>（包括插入、修改、删除也是写）<span style="margin:0px;padding:0px;color:#0000ff;">都在内存中进行</span></span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:28px;">，</span></span></p>
<p style="margin-top:10px;margin-bottom:10px;padding:0px;text-indent:28px;font-family:宋体;"><span style="margin:0px;padding:0px;color:#0000ff;background-color:#ffffff;"><span style="margin:0px;padding:0px;font-size:10.5pt;">数据首先会插入内存中的树。</span><span style="margin:0px;padding:0px;line-height:28px;font-size:10.5pt;">当内存树的数据量超过设定阈值后，会进行合并操作。合并操作会从左至右便利内存中树的子节点 与 磁盘中树的子节点并进行合并，</span><span style="margin:0px;padding:0px;line-height:27.9934px;font-size:10.5pt;">会用最新更新的数据覆盖旧的数据（或者记录为不同版本）</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:28px;">。当被合并合并数据量达到磁盘的存储页大小时。会将合并后的数据持久化到磁盘，同时更新父节点对子节点的指针。</span></span></p>
<p style="margin-top:10px;margin-bottom:10px;padding:0px;text-indent:28px;font-family:宋体;line-height:28px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;color:#ff0000;font-size:10.5pt;">LSM树 读数据&nbsp;</span><span style="margin:0px;padding:0px;color:#333333;font-size:10.5pt;">磁盘中书的非子节点数据也被缓存到内存中。</span><span style="margin:0px;padding:0px;line-height:28px;font-size:10.5pt;color:#333333;">在需要进行读操作时，</span><span style="margin:0px;padding:0px;line-height:28px;font-size:10.5pt;color:#0000ff;">总是从内存中的排序树开始搜索</span><span style="margin:0px;padding:0px;line-height:28px;font-size:10.5pt;color:#333333;">，如果没有找到，就从磁盘上的排序树顺序查找。</span></span></p>
<p style="margin-top:10px;margin-bottom:10px;padding:0px;text-indent:28px;font-family:宋体;line-height:28px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;color:#333333;">在LSM树上进行一次数据更新不需要磁盘访问，在内存即可完成，速度远快于B+树。当数据访问以写操作为主，而读操作则集中在最近写入的数据上时，使用</span><span style="margin:0px;padding:0px;color:#0000ff;">LSM树可以极大程度地减少磁盘的访问次数，加快访问速度。</span></span></p>
<p style="margin-top:10px;margin-bottom:10px;padding:0px;text-indent:28px;font-family:宋体;line-height:28px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;color:#ff0000;">LSM树 删除数据 前面讲了。LSM树所有操作都是在内存中进行的，那么删除并不是物理删除。而是一个逻辑删除，会在被删除的数据上打上一个标签，当内存中的数据达到阈值的时候，会与内存中的其他数据一起顺序写入磁盘。 这种操作会占用一定空间，但是LSM-Tree 提供了一些机制回收这些空间。</span><span style="margin:0px;padding:0px;color:#0000ff;"><br style="margin:0px;padding:0px;" />
</span></span></p>
<p style="margin-top:10px;margin-bottom:10px;padding:0px;text-indent:28px;font-family:宋体;line-height:28px;"><span style="margin:0px;padding:0px;color:#0000ff;background-color:#ffffff;">&nbsp;</span></p>
<p style="margin-top:10px;margin-bottom:10px;padding:0px;text-indent:28px;color:#333333;font-family:宋体;line-height:28px;"><span style="margin:0px;padding:0px;background-color:#ffffff;">作为存储结构，B+树不是关系数据库所独有的，NoSQL数据库也可以使用B+树。同理，关系数据库也可以使用LSM，而且随着SSD硬盘的日趋成熟及大容量持久存储的内存技术的出现，相信B+树这一"古老"的存储结构会再次焕发青春。</span></p>
<p style="margin:10px auto;padding:0px;">&nbsp;</p>
</div>
<div style="margin:0px;padding:0px;background-color:transparent;"><span style="margin:0px;padding:0px;background-color:#ffffff;">&nbsp;</span></div>
<div style="margin:0px;padding:0px;background-color:transparent;"><span style="margin:0px;padding:0px;background-color:#ffffff;">&nbsp;</span></div>
<div style="margin:0px;padding:0px;background-color:transparent;"><span style="margin:0px;padding:0px;background-color:#ffffff;">&nbsp;</span></div>
<div style="margin:0px;padding:0px;background-color:transparent;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">小结</span><br style="margin:0px;padding:0px;" />
</span></div>
<div style="margin:0px;padding:0px;background-color:transparent;"><p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">二叉树</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">：，每个结点只存储一个关键字，等于则命中，小于走左结点，大于</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">走右结点；</span></span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">二叉树</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">，B</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">树：多路搜索树，每个结点存储</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">M/2</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">到</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">M</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">个关键字，非叶子结点存储指向关键</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">字范围的子结点；</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">&nbsp;</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</span></span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;">&nbsp; &nbsp; &nbsp; &nbsp; B+</span><span style="margin:0px;padding:0px;">树：在</span>B<span style="margin:0px;padding:0px;">树基础上，为子结点增加链表指针，所有关键字都在子结点</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">中出现，非子结点作为子结点的索引；</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">B+</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">树总是到子结点才命中；</span></span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;background-color:#ffffff;">&nbsp; &nbsp; &nbsp; &nbsp; B*树：<span style="margin:0px;padding:0px;color:#ff0000;">（寻道）</span>在B+树基础上，为非子结点也增加链表指针，将结点的最低利用率<span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">从</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">1/2</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">提高到</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">2/3</span><span style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;">；</span></span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;font-family:微软雅黑;">&nbsp; &nbsp;&nbsp;</span><span style="margin:0px;padding:0px;font-family:微软雅黑;font-size:10.5pt;line-height:1.5;">&nbsp; &nbsp; LSM树：<span style="margin:0px;padding:0px;color:#ff0000;">（传输）</span>&nbsp;在 B+树 基础上， 将读写分离、读操作先内存后磁盘、</span><span style="margin:0px;padding:0px;font-size:10.5pt;font-family:宋体;line-height:28px;text-indent:28px;color:#0000ff;">数据写操作</span><span style="margin:0px;padding:0px;font-size:10.5pt;font-family:宋体;line-height:28px;text-indent:28px;">（包括插入、修改、删除也是写）</span><span style="margin:0px;padding:0px;font-size:10.5pt;font-family:宋体;line-height:28px;text-indent:28px;color:#0000ff;">都在内存中进行</span><span style="margin:0px;padding:0px;font-family:微软雅黑;font-size:10.5pt;line-height:1.5;">。到达一定阈值的时候才会刷新到磁盘上。（HBase 刷新到 memStore me） 在大规模情况下，寻道明显比传输低效。</span></span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;background-color:#ffffff;"><span style="margin:0px;padding:0px;font-family:punctuation;">&nbsp; &nbsp;&nbsp;</span><span style="margin:0px;padding:0px;font-family:punctuation;font-size:10.5pt;line-height:1.5;">&nbsp; &nbsp;<span style="margin:0px;padding:0px;color:#ff0000;">&nbsp;(从磁盘使用方面讲，有两种不同的数据库范式：一种是寻道，一种是传输)&nbsp;</span><span style="margin:0px;padding:0px;color:#0000ff;">RDBMS 通常都是寻道型的。主要是用于存储数据的B树 或 B+ 树结构引起的。 在磁盘寻道的速率级别上实现各种操作，通常每个访问需要 log(N)个寻道操作。</span></span><strong style="margin:0px;padding:0px;font-size:10.5pt;line-height:1.5;font-family:微软雅黑;"><span data-wiz-span="data-wiz-span" style="margin:0px;padding:0px;font-size:14pt;"><span style="margin:0px;padding:0px;color:#0000ff;"><span style="margin:0px;padding:0px;color:#ff0000;font-size:10.5pt;font-weight:normal;font-family:punctuation, &quot;Microsoft Yahei&quot;;line-height:25px;white-space:pre-wrap;widows:1;"><br style="margin:0px;padding:0px;" />
</span></span></span></strong></span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;font-family:punctuation;font-size:10.5pt;line-height:1.5;background-color:#ffffff;"><span style="margin:0px;padding:0px;color:#0000ff;">&nbsp;</span></span></p>
</div>
</div>
</div>
</div></body></html>