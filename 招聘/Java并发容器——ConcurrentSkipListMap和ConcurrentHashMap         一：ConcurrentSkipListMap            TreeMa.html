<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content=mNote Mac 2.5.11"/><meta name="created" content="2017-05-15T03:06:24Z"/><meta name="updated" content="2017-05-15T03:06:26Z"/><title>Java并发容器——ConcurrentSkipListMap和ConcurrentHashMap         一：ConcurrentSkipListMap            TreeMa</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><h1 class="postTitle" style="margin:0px 0px 20px;padding:0px;font-size:28px;font-weight:400;line-height:1.8;color:#333333;font-family:Verdana, Arial, Helvetica, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/ygj0930/p/6543901.html" style="margin:0px;padding:0px;color:#333333;text-decoration:none;">Java并发容器——ConcurrentSkipListMap和ConcurrentHashMap</a></h1>
<div class="clear" style="margin:0px;padding:0px;clear:both;color:#7d8b8d;font-family:Verdana, Arial, Helvetica, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"></div>
<div class="postBody" style="margin:0px;padding:0px;color:#7d8b8d;font-family:Verdana, Arial, Helvetica, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><div id="cnblogs_post_body" style="margin:0px 0px 20px;padding:0px;word-break:break-word;color:#333333;line-height:1.8;"><p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp; 一：ConcurrentSkipListMap</p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin:0px;padding:0px;">TreeMap使用红黑树按照key的顺序（自然顺序、自定义顺序）来使得键值对有序存储<em style="margin:0px;padding:0px;">，</em>但是只能在单线程下安全使用；多线程下想要使键值对按照key的顺序来存储，则需要使用ConcurrentSkipListMap。</span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ConcurrentSkipListMap的底层是通过跳表来实现的。跳表是一个链表，但是通过使用“跳跃式”查找的方式使得插入、读取数据时复杂度变成了O（logn）。</span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 跳表（SkipList）：使用“空间换时间”的算法，令链表的每个结点不仅记录next结点位置，还可以按照level层级分别记录后继第level个结点。在查找时，首先按照层级查找，比如：当前跳表最高层级为3，即每个结点中不仅记录了next结点（层级1），还记录了next的next（层级2）、next的next的next（层级3）结点。现在查找一个结点，则从头结点开始先按高层级开始查：head-&gt;head的next的next的next-&gt;。。。直到找到结点或者当前结点q的值大于所查结点，则此时当前查找层级的q的前一节点p开始，在p~q之间进行下一层级（隔1个结点）的查找......直到最终迫近、找到结点。此法使用的就是“<strong style="margin:0px;padding:0px;">先大步查找确定范围，再逐渐缩小迫近</strong>”的思想进行的查找。</span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 例如：有当前的跳表存储如下：有4个层级，层级1为最下面的level，是一个包含了所有结点的普通链表。往上数就是2，3，4层级。</span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （注：图来自 http://blog.csdn.net/sunxianghuang/article/details/52221913，如有冒犯，请见谅）</span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;"><img src="http://images2015.cnblogs.com/blog/1018541/201703/1018541-20170314151313463-1466475461.jpg" alt="" style="margin:0px;padding:0px;border:none;max-width:800px;" /></span></p>
<p style="margin:10px auto;padding:0px;">&nbsp;</p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在，我们查找结点值为19的结点：</span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;"><img src="http://images2015.cnblogs.com/blog/1018541/201703/1018541-20170314151526651-740353471.jpg" alt="" style="margin:0px;padding:0px;border:none;max-width:800px;" /></span></p>
<p style="margin:10px auto;padding:0px;">&nbsp;</p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 明白了查找的原理后，插入、删除就容易理解了。为了保存跳表的有序性，所以分三步：查找合适位置——进行插入/删除——更新跳表指针，维护层级性。</p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp; 插入结点：</p>
<p style="margin:10px auto;padding:0px;"><img src="http://images2015.cnblogs.com/blog/1018541/201703/1018541-20170314151827838-1483570327.png" alt="" style="margin:0px;padding:0px;border:none;max-width:800px;" /></p>
<p style="margin:10px auto;padding:0px;">&nbsp;</p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp; 删除结点：</p>
<p style="margin:10px auto;padding:0px;"><img src="http://images2015.cnblogs.com/blog/1018541/201703/1018541-20170314151843041-271757625.png" alt="" style="margin:0px;padding:0px;border:none;max-width:800px;" /></p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp; 知道了底层所用数据结构的原理后，我们来看看concurrentskiplistmap的部分源码：</p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp; 插入：</p>
<div class="cnblogs_code" style="margin:5px 0px;padding:5px;background-color:#f5f5f5;border:1px solid #cccccc;overflow:auto;color:#000000;font-family:&quot;Courier New&quot; !important;font-size:12px !important;"><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
<pre style="margin-top:0px;margin-bottom:0px;padding:0px;white-space:pre-wrap;word-wrap:break-word;font-family:'Courier New' !important;"><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">private</span> V doPut(K kkey, V value, <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">boolean</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> onlyIfAbsent) {
    Comparable</span>&lt;? <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">super</span> K&gt; key =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> comparable(kkey);
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">for</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> (;;) {
        </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 找到key的前继节点</span>         Node&lt;K,V&gt; b =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> findPredecessor(key);
        </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 设置n为“key的前继节点的后继节点”，即n应该是“插入节点”的“后继节点”</span>         Node&lt;K,V&gt; n =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> b.next;
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">for</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> (;;) {
            </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (n != <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">) {
                Node</span>&lt;K,V&gt; f =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> n.next;
                </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 如果两次获得的b.next不是相同的Node，就跳转到”外层for循环“，重新获得b和n后再遍历。</span>                 <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (n !=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> b.next)
                    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">break</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
                </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> v是“n的值”</span>                 Object v =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> n.value;
                </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 当n的值为null(意味着其它线程删除了n)；此时删除b的下一个节点，然后跳转到”外层for循环“，重新获得b和n后再遍历。</span>                 <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (v == <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span>) {               <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> n is deleted</span> <span style="margin:0px;padding:0px;line-height:1.5 !important;">                    n.helpDelete(b, f);
                    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">break</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
                }
                </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 如果其它线程删除了b；则跳转到”外层for循环“，重新获得b和n后再遍历。</span>                 <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (v == n || b.value == <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span>) <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> b is deleted</span>                     <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">break</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
                </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 比较key和n.key</span>                 <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span> c =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> key.compareTo(n.key);
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (c &gt; 0<span style="margin:0px;padding:0px;line-height:1.5 !important;">) {
                    b </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> n;
                    n </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> f;
                    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">continue</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
                }
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (c == 0<span style="margin:0px;padding:0px;line-height:1.5 !important;">) {
                    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (onlyIfAbsent ||<span style="margin:0px;padding:0px;line-height:1.5 !important;"> n.casValue(v, value))
                        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> (V)v;
                    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">else</span>                         <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">break</span>; <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> restart if lost race to replace value</span> <span style="margin:0px;padding:0px;line-height:1.5 !important;">                }
                </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> else c &lt; 0; fall through</span> <span style="margin:0px;padding:0px;line-height:1.5 !important;">            }

            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 新建节点(对应是“要插入的键值对”)</span>             Node&lt;K,V&gt; z = <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">new</span> Node&lt;K,V&gt;<span style="margin:0px;padding:0px;line-height:1.5 !important;">(kkey, value, n);
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 设置“b的后继节点”为z</span>             <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (!<span style="margin:0px;padding:0px;line-height:1.5 !important;">b.casNext(n, z))
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">break</span>;         <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 多线程情况下，break才可能发生(其它线程对b进行了操作)
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 随机获取一个level
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 然后在“第1层”到“第level层”的链表中都插入新建节点</span>             <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span> level =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> randomLevel();
            </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (level &gt; 0<span style="margin:0px;padding:0px;line-height:1.5 !important;">)
                insertIndex(z, level);
            </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
        }
    }
}</span></pre><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
</div>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp; 删除：</p>
<div class="cnblogs_code" style="margin:5px 0px;padding:5px;background-color:#f5f5f5;border:1px solid #cccccc;overflow:auto;color:#000000;font-family:&quot;Courier New&quot; !important;font-size:12px !important;"><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
<pre style="margin-top:0px;margin-bottom:0px;padding:0px;white-space:pre-wrap;word-wrap:break-word;font-family:'Courier New' !important;"><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">final</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> V doRemove(Object okey, Object value) {
    Comparable</span>&lt;? <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">super</span> K&gt; key =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> comparable(okey);
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">for</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> (;;) {
        </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 找到“key的前继节点”</span>         Node&lt;K,V&gt; b =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> findPredecessor(key);
        </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 设置n为“b的后继节点”(即若key存在于“跳表中”，n就是key对应的节点)</span>         Node&lt;K,V&gt; n =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> b.next;
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">for</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> (;;) {
            </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (n == <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">)
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> f是“当前节点n的后继节点”</span>             Node&lt;K,V&gt; f =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> n.next;
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 如果两次读取到的“b的后继节点”不同(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。</span>             <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (n != b.next)                    <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> inconsistent read</span>                 <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">break</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 如果“当前节点n的值”变为null(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。</span>             Object v =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> n.value;
            </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (v == <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span>) {                    <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> n is deleted</span> <span style="margin:0px;padding:0px;line-height:1.5 !important;">                n.helpDelete(b, f);
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">break</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
            }
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 如果“前继节点b”被删除(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。</span>             <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (v == n || b.value == <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span>)      <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> b is deleted</span>                 <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">break</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
            </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span> c =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> key.compareTo(n.key);
            </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (c &lt; 0<span style="margin:0px;padding:0px;line-height:1.5 !important;">)
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
            </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (c &gt; 0<span style="margin:0px;padding:0px;line-height:1.5 !important;">) {
                b </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> n;
                n </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> f;
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">continue</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
            }

            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 以下是c=0的情况</span>             <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (value != <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span> &amp;&amp; !<span style="margin:0px;padding:0px;line-height:1.5 !important;">value.equals(v))
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 设置“当前节点n”的值为null</span>             <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (!n.casValue(v, <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">))
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">break</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 设置“b的后继节点”为f</span>             <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (!n.appendMarker(f) || !<span style="margin:0px;padding:0px;line-height:1.5 !important;">b.casNext(n, f))
                findNode(key);                  </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> Retry via findNode</span>             <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">else</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> {
                </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 清除“跳表”中每一层的key节点</span>                 findPredecessor(key);           <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> Clean index
                </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 如果“表头的右索引为空”，则将“跳表的层次”-1。</span>                 <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (head.right == <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">)
                    tryReduceLevel();
            }
            </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> (V)v;
        }
    }
}</span></pre><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
</div>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp; 查找：</p>
<div class="cnblogs_code" style="margin:5px 0px;padding:5px;background-color:#f5f5f5;border:1px solid #cccccc;overflow:auto;color:#000000;font-family:&quot;Courier New&quot; !important;font-size:12px !important;"><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
<pre style="margin-top:0px;margin-bottom:0px;padding:0px;white-space:pre-wrap;word-wrap:break-word;font-family:'Courier New' !important;"><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">private</span> Node&lt;K,V&gt; findNode(Comparable&lt;? <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">super</span> K&gt;<span style="margin:0px;padding:0px;line-height:1.5 !important;"> key) {
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">for</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> (;;) {
        </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 找到key的前继节点</span>         Node&lt;K,V&gt; b =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> findPredecessor(key);
        </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 设置n为“b的后继节点”(即若key存在于“跳表中”，n就是key对应的节点)</span>         Node&lt;K,V&gt; n =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> b.next;
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">for</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> (;;) {
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 如果“n为null”，则跳转中不存在key对应的节点，直接返回null。</span>             <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (n == <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">)
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
            Node</span>&lt;K,V&gt; f =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> n.next;
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 如果两次读取到的“b的后继节点”不同(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。</span>             <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (n != b.next)                <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> inconsistent read</span>                 <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">break</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
            Object v </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> n.value;
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 如果“当前节点n的值”变为null(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。</span>             <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (v == <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span>) {                <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> n is deleted</span> <span style="margin:0px;padding:0px;line-height:1.5 !important;">                n.helpDelete(b, f);
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">break</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
            }
            </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (v == n || b.value == <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span>)  <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> b is deleted</span>                 <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">break</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 若n是当前节点，则返回n。</span>             <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span> c =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> key.compareTo(n.key);
            </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (c == 0<span style="margin:0px;padding:0px;line-height:1.5 !important;">)
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> n;
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 若“节点n的key”小于“key”，则说明跳表中不存在key对应的节点，返回null</span>             <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (c &lt; 0<span style="margin:0px;padding:0px;line-height:1.5 !important;">)
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
            </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 若“节点n的key”大于“key”，则更新b和n，继续查找。</span>             b =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> n;
            n </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> f;
        }
    }
}</span></pre><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
</div>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过上面的源码可以发现：<strong style="margin:0px;padding:0px;">ConcurrentSkipListMap线程安全的原理与非阻塞队列ConcurrentBlockingQueue的原理一样：利用底层的插入、删除的CAS原子性操作，通过死循环不断获取最新的结点指针来保证不会出现竞态条件。</strong></p>
<p style="margin:10px auto;padding:0px;">&nbsp;</p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp; 二：ConcurrentHashMap</p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin:0px;padding:0px;">快速存取&lt;Key, Value&gt;键值对使用HashMap；多线程并发存取&lt;Key, Value&gt;键值对使用ConcurrentHashMap；</span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们知道，HashTable和和Collections类中提供的同步HashTable是线程安全的，但是他们线程安全是通过在进行读写操作时对整个map加锁来实现的，故此性能比较低。那既然是由于锁粒度（加锁的范围叫锁粒度）太大造成的性能低下，可不可以从锁粒度着手去改良呢？由此，就引申出了ConcurrentHashMap。</span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ConcurrentHashMap采取了“锁分段”技术来细化锁的粒度：把整个map划分为一系列被成为segment的组成单元，一个segment相当于一个小的hashtable。这样，加锁的对象就从整个map变成了一个更小的范围——一个segment。<strong style="margin:0px;padding:0px;">ConcurrentHashMap线程安全并且提高性能原因就在于：对map中的读是并发的，无需加锁；只有在put、remove操作时才加锁，而加锁仅是对需要操作的segment加锁，不会影响其他segment的读写，由此，不同的segment之间可以并发使用，极大地提高了性能。</strong></span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1：结构分析</span></p>
<p style="margin:10px auto;padding:0px;"><span style="margin:0px;padding:0px;"><img src="http://images2015.cnblogs.com/blog/1018541/201703/1018541-20170314163847229-1659547883.png" alt="" style="margin:0px;padding:0px;border:none;max-width:800px;" /></span></p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp; Segment的结构：</p>
<div class="cnblogs_code" style="margin:5px 0px;padding:5px;background-color:#f5f5f5;border:1px solid #cccccc;overflow:auto;color:#000000;font-family:&quot;Courier New&quot; !important;font-size:12px !important;"><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
<pre style="margin-top:0px;margin-bottom:0px;padding:0px;white-space:pre-wrap;word-wrap:break-word;font-family:'Courier New' !important;"><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">static</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">final</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">class</span> Segment&lt;K,V&gt; <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">extends</span> ReentrantLock <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">implements</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> Serializable {
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">transient</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">volatile</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> count;
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">transient</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> modCount;
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">transient</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> threshold;
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">transient</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">volatile</span> HashEntry&lt;K,V&gt;<span style="margin:0px;padding:0px;line-height:1.5 !important;">[] table;
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">final</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">float</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> loadFactor;
}</span></pre><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
</div>
<ul style="margin:0.4em 0px 1em;padding:0px;line-height:19px;font-family:'Helvetica Neue', Helvetica, Arial, Geneva, 'MS Sans Serif', sans-serif;"><li style="margin:0px 0px 0px 2.5em;padding:0px;list-style:disc;">count：<strong style="margin:0px;padding:0px;">Segment中元素的数量，用于map.size()时统计整个map的大小使用</strong></li>
<li style="margin:0px 0px 0px 2.5em;padding:0px;list-style:disc;">modCount：对table的大小造成影响的操作的数量（比如put或者remove操作），<strong style="margin:0px;padding:0px;">用于统计size时验证结果的正确性</strong></li>
<li style="margin:0px 0px 0px 2.5em;padding:0px;list-style:disc;">threshold：阈值，Segment里面元素的数量超过这个值依旧就会对Segment进行扩容，concurrenthashmap自身不会扩容（<strong style="margin:0px;padding:0px;">segment的数量在map创建后不会再增加，在容量不足时只会增加segment的容量</strong>）</li>
<li style="margin:0px 0px 0px 2.5em;padding:0px;list-style:disc;">table：链表数组，数组中的每一个元素代表了一个链表的头部，<strong style="margin:0px;padding:0px;">一个链表用于存储相同hash值的不同元素们</strong></li>
<li style="margin:0px 0px 0px 2.5em;padding:0px;list-style:disc;">loadFactor：负载因子，用于确定threshold，<strong style="margin:0px;padding:0px;">决定扩容的时机</strong></li>
</ul>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;</p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp; 2：查询</p>
<div class="cnblogs_code" style="margin:5px 0px;padding:5px;background-color:#f5f5f5;border:1px solid #cccccc;overflow:auto;color:#000000;font-family:&quot;Courier New&quot; !important;font-size:12px !important;"><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
<pre style="margin-top:0px;margin-bottom:0px;padding:0px;white-space:pre-wrap;word-wrap:break-word;font-family:'Courier New' !important;"><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">static</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">final</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">class</span> HashEntry&lt;K,V&gt;<span style="margin:0px;padding:0px;line-height:1.5 !important;"> {
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">final</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> K key;
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">final</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> hash;
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">volatile</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> V value;
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">final</span> HashEntry&lt;K,V&gt;<span style="margin:0px;padding:0px;line-height:1.5 !important;"> next;
}</span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">final</span> Segment&lt;K,V&gt; segmentFor(<span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> hash) {
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp;<span style="margin:0px;padding:0px;line-height:1.5 !important;"> segmentMask];
}

V get(Object key, </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> hash) {
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (count != 0) { <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> read-volatile</span>         HashEntry&lt;K,V&gt; e =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> getFirst(hash);
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">while</span> (e != <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">) {
            </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (e.hash == hash &amp;&amp;<span style="margin:0px;padding:0px;line-height:1.5 !important;"> key.equals(e.key)) {
                V v </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> e.value;
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (v != <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">)
                    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> v;
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span> readValueUnderLock(e); <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> recheck</span> <span style="margin:0px;padding:0px;line-height:1.5 !important;">            }
            e </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> e.next;
        }
    }
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
}

HashEntry</span>&lt;K,V&gt; getFirst(<span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> hash) {
    HashEntry</span>&lt;K,V&gt;[] tab =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> table;
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span> tab[hash &amp; (tab.length - 1<span style="margin:0px;padding:0px;line-height:1.5 !important;">)];
}</span></pre><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
</div>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp; 由上面可以看到：<strong style="margin:0px;padding:0px;">concurrenthashmap的查询操作经过三步：第一次hash确定key在哪个segment中；第二次hash在segment中确定key在链表数组的哪个链表中；第三步遍历这个链表，调用equals()进行比对，找到与所查找key相等的结点并读取。</strong></p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp; 3：插入</p>
<div class="cnblogs_code" style="margin:5px 0px;padding:5px;background-color:#f5f5f5;border:1px solid #cccccc;overflow:auto;color:#000000;font-family:&quot;Courier New&quot; !important;font-size:12px !important;"><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
<pre style="margin-top:0px;margin-bottom:0px;padding:0px;white-space:pre-wrap;word-wrap:break-word;font-family:'Courier New' !important;">V put(K key, <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span> hash, V value, <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">boolean</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> onlyIfAbsent) {
    lock();
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">try</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> {
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span> c =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> count;
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (c++ &gt; threshold) <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> ensure capacity</span> <span style="margin:0px;padding:0px;line-height:1.5 !important;">            rehash();
        HashEntry</span>&lt;K,V&gt;[] tab =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> table;
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span> index = hash &amp; (tab.length - 1<span style="margin:0px;padding:0px;line-height:1.5 !important;">);
        HashEntry</span>&lt;K,V&gt; first =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> tab[index];
        HashEntry</span>&lt;K,V&gt; e =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> first;
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">while</span> (e != <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span> &amp;&amp; (e.hash != hash || !<span style="margin:0px;padding:0px;line-height:1.5 !important;">key.equals(e.key)))
            e </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> e.next;
  
        V oldValue;
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (e != <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">) {
            oldValue </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> e.value;
            </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (!<span style="margin:0px;padding:0px;line-height:1.5 !important;">onlyIfAbsent)
                e.value </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> value;
        }
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">else</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> {
            oldValue </span>= <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
            </span>++<span style="margin:0px;padding:0px;line-height:1.5 !important;">modCount;
            tab[index] </span>= <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">new</span> HashEntry&lt;K,V&gt;<span style="margin:0px;padding:0px;line-height:1.5 !important;">(key, hash, first, value);
            count </span>= c; <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> write-volatile</span> <span style="margin:0px;padding:0px;line-height:1.5 !important;">        }
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> oldValue;
    } </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">finally</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> {
        unlock();
    }
}</span></pre><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
</div>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 插入过程也分三步：<strong style="margin:0px;padding:0px;">首先由key值经过hash计算得到是哪个segment，如果segment大小以及到达阀值则扩容；然后再次hash确定key所在链表的数组下标，获取链表头；最后遍历链表，如果找到相同的key的结点则更新value值，如果没有则插入新结点；</strong></p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp; 4：删除</p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment的链表数组中的链表结构如下：</p>
<div class="cnblogs_code" style="margin:5px 0px;padding:5px;background-color:#f5f5f5;border:1px solid #cccccc;overflow:auto;color:#000000;font-family:&quot;Courier New&quot; !important;font-size:12px !important;"><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
<pre style="margin-top:0px;margin-bottom:0px;padding:0px;white-space:pre-wrap;word-wrap:break-word;font-family:'Courier New' !important;"><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">static</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">final</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">class</span> HashEntry&lt;K,V&gt;<span style="margin:0px;padding:0px;line-height:1.5 !important;"> {
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">final</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> K key;
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">final</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> hash;
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">volatile</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> V value;
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">final</span> HashEntry&lt;K,V&gt;<span style="margin:0px;padding:0px;line-height:1.5 !important;"> next;
}</span></pre><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
</div>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们可以看到，链表中结点只有value是可修改的，因此，如果我们需要删除结点时，是不能简单地由前继结点指向被删结点的后继结点来实现。所以，我们只能重构链表。</p>
<div class="cnblogs_code" style="margin:5px 0px;padding:5px;background-color:#f5f5f5;border:1px solid #cccccc;overflow:auto;color:#000000;font-family:&quot;Courier New&quot; !important;font-size:12px !important;"><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
<pre style="margin-top:0px;margin-bottom:0px;padding:0px;white-space:pre-wrap;word-wrap:break-word;font-family:'Courier New' !important;">V remove(Object key, <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> hash, Object value) {
    lock();
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">try</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> {
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span> c = count - 1<span style="margin:0px;padding:0px;line-height:1.5 !important;">;
        HashEntry</span>&lt;K,V&gt;[] tab =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> table;
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span> index = hash &amp; (tab.length - 1<span style="margin:0px;padding:0px;line-height:1.5 !important;">);
        HashEntry</span>&lt;K,V&gt; first =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> tab[index];
        HashEntry</span>&lt;K,V&gt; e =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> first;
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">while</span> (e != <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span> &amp;&amp; (e.hash != hash || !<span style="margin:0px;padding:0px;line-height:1.5 !important;">key.equals(e.key)))
            e </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> e.next;
  
        V oldValue </span>= <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">;
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (e != <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">) {
            V v </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> e.value;
            </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">if</span> (value == <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">null</span> ||<span style="margin:0px;padding:0px;line-height:1.5 !important;"> value.equals(v)) {
                oldValue </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> v;
                </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> All entries following removed node can stay
                </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> in list, but all preceding ones need to be
                </span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> cloned.</span>                 ++<span style="margin:0px;padding:0px;line-height:1.5 !important;">modCount;
                HashEntry</span>&lt;K,V&gt; newFirst =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> e.next;
                </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">for</span> (HashEntry&lt;K,V&gt; p = first; p != e; p =<span style="margin:0px;padding:0px;line-height:1.5 !important;"> p.next)
                    newFirst </span>= <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">new</span> HashEntry&lt;K,V&gt;<span style="margin:0px;padding:0px;line-height:1.5 !important;">(p.key, p.hash,
                                                  newFirst, p.value);
                tab[index] </span>=<span style="margin:0px;padding:0px;line-height:1.5 !important;"> newFirst;
                count </span>= c; <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">//</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> write-volatile</span> <span style="margin:0px;padding:0px;line-height:1.5 !important;">            }
        }
        </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">return</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> oldValue;
    } </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">finally</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> {
        unlock();
    }
}</span></pre><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:800px;border:none !important;" /></a></span></div>
</div>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">删除过程：首先由key经过hash确定所在segment；然后再hash确定具体的数组下标，获得链表头；最后遍历链表，找到被删除结点后，以被删除结点的next结点开始建立新的链表，然后再把原链表头直到被删结点的前继结点依次复制、插入新链表，最后把新链表头设置为当前数组下标元素取代旧链表。</strong></p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp; 5：统计大小—Size()</p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 统计整个map的大小时，如果在统计过程中把整个map锁住，则会造成影响读写。ConcurrentHashMap通过采用segment中的属性成员来优化这个过程。</p>
<div class="cnblogs_code" style="margin:5px 0px;padding:5px;background-color:#f5f5f5;border:1px solid #cccccc;overflow:auto;color:#000000;font-family:&quot;Courier New&quot; !important;font-size:12px !important;"><pre style="margin-top:0px;margin-bottom:0px;padding:0px;white-space:pre-wrap;word-wrap:break-word;font-family:'Courier New' !important;"><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">static</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">final</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">class</span> Segment&lt;K,V&gt; <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">extends</span> ReentrantLock <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">implements</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> Serializable {
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">transient</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">volatile</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> count;
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">transient</span> <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> modCount;
   ....
}</span></pre></div>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们看到，每个segment中有一个count记录当前segment的元素数量，每当put/remove成功就会把这个值+1/-1。因此，在统计map的大小时，我们把每个segment的count加起来就是了。但是，如果在加的过程中，发生了修改怎么办呢？比如：把segment[2]的count加到total后，segment[2]发生了remove操作，这样就会造成统计结果不正确。此时就需要用modCount，modCount记录了segment的修改次数，这个值只增不减，无论是插入、删除都会导致该值+1.</p>
<p style="margin:10px auto;padding:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style="margin:0px;padding:0px;">&nbsp;ConcurrentHashMap在统计size时，经历了两次遍历：第一次不加锁地遍历所以segment，统计count和modCount的总和得到C1和M1；然后再次不加锁地遍历，得到C2和M2，比较M1和M2，如果修改次数没有发生变化则说明两次遍历期间map没有发生数量变化，那么C1就是可用的。如果M1不等于M2，则说明在统计过程中map的数量发生了变化，此时才采取最终手段——锁住整个map进行统计。</strong></p>
</div>
<div id="MySignature" style="margin:0px;padding:0px;">到我的github上查看更多项目：https://github.com/ygj0930</div>
</div></body></html>