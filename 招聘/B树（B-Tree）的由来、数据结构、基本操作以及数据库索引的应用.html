<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content=mNote Mac 2.5.11"/><meta name="created" content="2017-06-07T06:42:01Z"/><meta name="updated" content="2017-06-07T06:42:16Z"/><title>B树（B-Tree）的由来、数据结构、基本操作以及数据库索引的应用</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><h1 class="postTitle" style="margin:0px;padding:0px;font-size:1.5em;line-height:1.5em;width:725px;clear:both;text-align:center;font-family:tahoma, arial, sans-serif;font-variant-ligatures:normal;orphans:2;widows:2;"><br />
</h1>
<div class="clear" style="margin:0px;padding:0px;clear:both;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;"></div>
<div class="postBody" style="margin:0px;padding:5px;line-height:1.5;color:#444444;font-family:tahoma, arial, sans-serif;font-size:12px;font-variant-ligatures:normal;orphans:2;widows:2;"><div id="cnblogs_post_body" style="margin:0px 0px 20px;padding:0px;word-break:break-word;"><blockquote style="margin:10px 0px;padding:10px 60px 5px;background:url(&quot;images/comment.gif&quot;) 25px 0px no-repeat;border:2px solid #efefef;min-height:35px;line-height:1.6em;color:#333333;"><p style="margin:10px auto;padding:0px;line-height:1.5 !important;">B树是为磁盘存储而专门设计的一类平衡搜索树，B树的高度仅随着它所包含的节点数按对数增长，不过因为单个节点可以包含多个关键字，所以对数的底数可以比较大，实际应用中一般是50~2000，给个直观的数字，一棵分支因子为1001、高度为2（不包含根节点）的B树，可以存储超过10亿个关键字！</p>
</blockquote>
<h3 style="margin:10px 0px;padding:0px;font-size:16px;line-height:1.5;">1.从磁盘结构讲起</h3>
<p style="margin:10px auto;padding:0px;line-height:1.5 !important;">计算机的机械磁盘，为了摊还机械移动花费的等待时间，磁盘会一次存取多个数据项而不是一个，这样的一次读取的信息单元是page，我们可以用读或写的页数作为磁盘存取总时间的主要近似值，在任何时刻，B树算法都只需在内存中保持一定数量的页面。B树的设计考虑磁盘预读取这点，一个B树的节点通常和一个完整磁盘页（page）一样大，并且磁盘页的大小限制了一个B树节点可以含有的孩子个数（分支因子），当然这个具体也需要取决于一个关键字相对一页的大小。B+ Tree中内部节点只存放关键字和孩子的指针，不存其他satellite information，因此最大化了内部节点的分支因子。</p>
<h3 style="margin:10px 0px;padding:0px;font-size:16px;line-height:1.5;">2.B树的数据结构</h3>
<div class="cnblogs_code" style="margin:5px 0px;padding:5px;background-color:#f5f5f5;border:1px solid #cccccc;overflow:auto;color:#000000;font-family:'Courier New' !important;line-height:1.5 !important;"><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;line-height:1.5 !important;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;color:#444444;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:660px;border:none !important;" /></a></span></div>
<pre style="margin-top:0px;margin-bottom:0px;padding:0px;white-space:pre-wrap;word-wrap:break-word;font-family:'Courier New' !important;"><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">typedef int KeyType;
#define m 3  
struct</span><span style="margin:0px;padding:0px;line-height:1.5 !important;"> Node{  
    </span><span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">int</span> keynum;             <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">/*</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;"> 结点中关键字的个数，即结点的大小</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">*/</span>  
    <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">struct</span> Node *parent;    <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">/*</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">指向parent结点</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">*/</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">   
    KeyType key[m</span>];         <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">/*</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">关键字向量</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">*/</span>   
    <span style="margin:0px;padding:0px;color:#0000ff;line-height:1.5 !important;">struct</span> Node *ptr[m];    <span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">/*</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">子树指针向量</span><span style="margin:0px;padding:0px;color:#008000;line-height:1.5 !important;">*/</span><span style="margin:0px;padding:0px;line-height:1.5 !important;">  
};</span></pre><div class="cnblogs_code_toolbar" style="margin:5px 0px 0px;padding:0px;line-height:1.5 !important;"><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5 !important;"><a title="复制代码" style="margin:0px;padding:0px;color:#444444;text-decoration:underline;border:none !important;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;max-width:660px;border:none !important;" /></a></span></div>
</div>
<p style="margin:10px auto;padding:0px;line-height:1.5 !important;"><img src="http://images.cnitblog.com/blog/319578/201312/19232650-8e1a6f9333e24cfe8d02c854ea3d974d.gif" alt="" style="margin:0px;padding:0px;border:0px;max-width:660px;" /></p>
<h3 style="margin:10px 0px;padding:0px;font-size:16px;line-height:1.5;">3.B树的查找</h3>
<p style="margin:10px auto;padding:0px;line-height:1.5 !important;">搜索一棵B树和搜索一棵二叉搜索树很相似，只是在每个节点所做的不是二叉或者“两路”分支选择，而是根据根节点的孩子数做多路分支选择。</p>
<h3 style="margin:10px 0px;padding:0px;font-size:16px;line-height:1.5;">4.B树的插入</h3>
<p style="margin:10px auto;padding:0px;line-height:1.5 !important;">B树插入的时候都是插入到叶节点上，插入的时候会从根节点开始顺着叶节点的方向沿途，如果遇到一个满节点（该节点上的关键字达到2t-1，t代表t阶B树），就会split该节点，分裂节点方式就是把满节点上的中间关键字往根节点方向提，分裂是树长高的唯一途径。B树的每个叶节点具有相同的高度，所以B树高度的增加发生在顶部而不是底部。插入节点的时候，从根的方向往下判断，如果不是叶子节点，则必须选择适当的叶子节点插入，因为在沿途已经分裂了节点，所以保证不会在满节点上再插入节点。</p>
<h3 style="margin:10px 0px;padding:0px;font-size:16px;line-height:1.5;">5.B树的删除</h3>
<p style="margin:10px auto;padding:0px;line-height:1.5 !important;">和插入关键字类似，插入关键字的时候要保证节点不会太大，而且有可能会增高B树。删除节点的时候要保证一个节点不会变得太小，因为B树的节点上的关键字有下界要求（除了根节点以外的每个内部节点至少有t个孩子，如果树非空，根节点上至少有一个关键字），删除关键字的时候如果在叶子节点，而且删除之后还满足B树的要求，那直接删除即可，不过如果是其他情况，比如在内部节点上删除关键字，那就有一系列的算法分支需要考虑，感兴趣的读者可以自行找资料慢慢琢磨了。不过在实际场景中，由于一棵B树中大部分关键字都在叶节点中，删除操作最经常是从叶子节点中删除关键字。</p>
<h3 style="margin:10px 0px;padding:0px;font-size:16px;line-height:1.5;">6.B树的应用场景&nbsp;</h3>
<p style="margin:10px auto;padding:0px;line-height:1.5 !important;">mysql的MyISAM和InnoDB两个存储引擎的索引实现方式：</p>
<ul style="margin:0px 0px 0px 30px;padding:0px;word-break:break-all;"><li style="margin:0px 0px 1em;padding:0px;list-style:disc;">MyISAM引擎使用B+ Tree作为索引结构，叶节点存放的是数据记录的地址。</li>
<li style="margin:0px 0px 1em;padding:0px;list-style:disc;">MyISAM引擎的辅助索引（二级索引）和主索引在结构上没有区别，只是辅助索引的key可以重复，叶节点上存放的也是数据记录的地址。</li>
<li style="margin:0px 0px 1em;padding:0px;list-style:disc;">MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</li>
<li style="margin:0px 0px 1em;padding:0px;list-style:disc;">InnoDB中表数据本身就是按B+ Tree组织的一个索引结构，叶节点存放的就不是数据记录的地址，而是完整的数据记录。所以InnoDB这种存储方式，又称为聚集索引，使得按主键的搜索十分高效，但二级索引搜索需要检索两遍索引：首先二级索引获得主键，然后用主键到主索引中检索到数据记录。</li>
<li style="margin:0px 0px 1em;padding:0px;list-style:disc;">因为主键是InnoDB表记录的”逻辑地址“，所以InnoDB要求表必须有主键，MyISAM可以没有。</li>
</ul>
</div>
</div></body></html>